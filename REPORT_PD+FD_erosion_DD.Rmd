---
title: "Erosion of phylogenetic and functional diversity in Amphibians"
author: "Brunno F Oliveira^1^; Gabriel C Costa^1^"
date: "October 20, 2015\n**1** Programa de Pós-graduação em Ecologia, Universidade
  Federal do Rio Grande do Norte, Lagoa Nova, 59072-970, Natal, RN, Brazil. **Corresponding
  author:** (brunno.oliveira@me.com) "
output: pdf_document
theme: united
toc: yes
---

*** 

\newpage


Packages versions:
```{r info, message=FALSE, echo=F}
info <- sessionInfo()
```

We used `r info[1]$R$ver` and the following packages:
```{r packages, message=FALSE}
library(rmarkdown);library(sp);library(rgdal);library(raster);library(maptools);
library(maps);library(maptools);library(rgeos);library(raster);library(stringr);
library(picante);library(ape);library(rgdal);library(ggplot2);library(geiger);
library(ade4);library(foreach);library(parallel);library(doParallel);
library(PBSmapping);library(nabor);library(plot3D);library(knitr);library(vegan);
library(phytools);library(rworldmap);library(FD);library(hypervolume);library(BAMMtools)
```

```{r echo=F, results="hide"}
rm(list=ls())
gc()
```

```{r echo=F}
#Load data

setwd("/media/brunno/FAT/Chap3/R_code_DD")
#setwd("F:/Chap3/R_code_DD")

# loading for the first time
# load("PD+FD_erosion_getdata.RData")

# load this if you have already done the job
load("PD+FD_erosion.RData")
```


# Load some functions
```{r eval = F}
#### function to get equal binds from a vector
func_splint <- function(x,interval=4) {
  is.odd <- function(x) x %% 2 != 0

  a <- levels(cut_interval(x,interval-1))
  b <- unlist(strsplit(a,','))
  c <- gsub('[','',b,fixed="TRUE")
  d <- gsub(']','',c,fixed="TRUE")
  e <- gsub('(','',d,fixed="TRUE")
  f <- gsub(')','',e,fixed="TRUE")
  return(as.numeric(c(unique(f))))
}

#### function to random sample n species in a community and calc pd
random.drop <- function(n, com, phy){
  # species in community i
  tipnames <- names(com)[which(com==1)]
  # random sample n species from community i
  sp.tmp <- sample(1:length(tipnames), n, replace = F)
  # these are the randomly sampled species
  tipnames <- tipnames[sp.tmp]
  # calculate PD
  trx <- drop.tip(tree, tree$tip.label[-na.omit(match(tipnames, tree$tip.label))])
  return(sum(trx$edge.length))
}

#### function to random sample n tips and calc pd
random.drop.phy <- function(n, phy){
  # random sample X species from that pool
  sp.tmp <- sample(1:length(phy$tip.label), n, replace = F)
  # null.dataset
  tipnames <- phy$tip.label[-sp.tmp]
  trx <- drop.tip(phy, tipnames)
  return(sum(trx$edge.length))
}

#### function to random sample n species and calc FD
random.fd <- function(n, com, td){
  # species in community i
  tipnames <- names(com)[which(com[i,]==1)]
  # random sample n species from community i
  sp.tmp <- sample(1:length(tipnames), n, replace = F)
  # these are the randomly sampled species
  tipnames <- tipnames[sp.tmp]
  # calculate FD
  tmp <- hypervolume(td[tipnames,], bandwidth = bandw, verbose = F, warnings=F, quantile = 0.05)
  tmp <- get_volume(tmp)
}

# Panel cor functions
panel.cor <- function(x, y, digits=2, cex.cor)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r <- abs(cor(x, y))
  txt <- format(c(r, 0.123456789), digits=digits)[1]
  test <- cor.test(x,y)
  Signif <- ifelse(round(test$p.value,3)<0.001,"p<0.001",paste("p=",round(test$p.value,3)))  
  text(0.5, 0.25, paste("r=",txt))
  text(.5, .75, Signif)
}
panel.smooth<-function (x, y, col = "blue", bg = NA, pch = 18, 
                        cex = 0.8, col.smooth = "red", span = 2/3, iter = 3, ...) 
{
  points(x, y, pch = pch, col = col, bg = bg, cex = cex)
  ok <- is.finite(x) & is.finite(y)
  if (any(ok)) 
    lines(stats::lowess(x[ok], y[ok], f = span, iter = iter), 
          col = col.smooth, ...)
}
panel.hist <- function(x, ...)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(usr[1:2], 0, 1.5) )
  h <- hist(x, plot = FALSE)
  breaks <- h$breaks; nB <- length(breaks)
  y <- h$counts; y <- y/max(y)
  rect(breaks[-nB], 0, breaks[-1], y, col="cyan", ...)
}
```

# 1. All amphibians' analysis:
## 1.1. Calculate species richness loss
```{r eval = F, results="hide"}
SPDTall <- dim(occr)[2]

SPDTS1 <- dim(occrS1)[2]
SPDTS2 <- dim(occrS2)[2]
```

Total Richness  
Controle: `r SPDTall`  
S1: `r SPDTS1` (`r round((SPDTS1/SPDTall)*100,1)`% Total Richness)  
S2: `r SPDTS2` (`r round((SPDTS2/SPDTall)*100,1)`% Total Richness)  
  
Total Richness loss  
S1: `r SPDTall-SPDTS1` (`r round(((SPDTall-SPDTS1)/SPDTall)*100,2)`% Total Richness)  
S2: `r SPDTall-SPDTS2` (`r round(((SPDTall-SPDTS2)/SPDTall)*100,2)`% Total Richness)
   
   
## 1.2. Calculate phylogenetic diversity (PD) loss
```{r eval = F, results="hide"}
PDTall <- sum(tree$edge.length)

PDTS1 <- sum(treeS1$edge.length)
# Test if PD loss is higher or lower than random.
PDTS1.null <- replicate(100, random.drop.phy(SPDTS1, tree))
PDTS1.P <- t.test(PDTS1.null, mu =  PDTS1) # t.test

PDTS2 <- sum(treeS2$edge.length)
# Test if PD loss is higher or lower than random
PDTS2.null <- replicate(100, random.drop.phy(SPDTS2, tree))
PDTS2.P <- t.test(PDTS2.null, mu = PDTS2) # t.test
```
  
Total PD  
Controle: $`r round(PDTall,2)`$  
S1: $`r round(PDTS1,2)`$ Myr ($`r round((PDTS1/PDTall)*100,1)`$% Total PD)  
S2: $`r round(PDTS2,2)`$ Myr ($`r round((PDTS2/PDTall)*100,1)`$% Total PD)  

Total PD loss (PDall - PDScenario)  
S1: $`r round(PDTall-PDTS1,2)`$ Myr ($`r round(((PDTall-PDTS1)/PDTall)*100,1)`$% Total PD) ; P-value = `r ifelse(PDTS1.P$p.value<0.001, "<0.001", "NS")`) ; Random expectation: Mean = $`r round(mean(PDTS1.null,2))`$, sd = $`r round(sd(PDTS1.null,2))`$.  
S2: $`r round(PDTall-PDTS2,2)`$ Myr ($`r round(((PDTall-PDTS2)/PDTall)*100,1)`$% Total PD) ; P-value = `r ifelse(PDTS2.P$p.value<0.001, "<0.001", "NS")`) ; Random expectation: Mean = $`r round(mean(PDTS2.null,2))`$, sd = $`r round(sd(PDTS2.null,2))`$.    

  
## 1.3. Calculate functional diversity (FD)  
```{r eval = F, results="hide"}
# We estimated bandwidths using the method of Silverman.

# calculate FD all
hyperT<-hypervolume(traits, repsperpoint=1000, bandwidth = estimate_bandwidth(traits),
                    verbose = F, warnings=F, quantile = 0.05)
FDTall <- get_volume(hyperT)

# calculate FD S1
hyperS1<-hypervolume(traitS1, repsperpoint=1000, bandwidth = estimate_bandwidth(traits),
                     verbose = F, warnings=F, quantile = 0.05)
FDTS1 <- get_volume(hyperS1)

# Simulate random extinctions for S1
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)
# calculate
FDTS1.null <- foreach(i=1:100, .combine='c', .packages='hypervolume') %dopar% { 
  get_volume(hypervolume(traits[sample(1:SPDTall, SPDTS1, replace = F),],
                         repsperpoint=1000, bandwidth = estimate_bandwidth(traits),
                         verbose = F, warnings=F, quantile = 0.05))
}
# stop the cluster
stopCluster(cl)

#Test if FD loss is higher or lower than random.
FDTS1.P <- t.test(FDTall-FDTS1.null, mu =  FDTall-FDTS1) # t.test

### Detect holes S1
# DETECT HOLES
featuresS1<-hypervolume_holes(hv_obs=hyperS1,hv_exp=hyperT,set_check_memory=F)
features_segmentedS1<-hypervolume_segment(featuresS1)
features_segmentedS1<-hypervolume_prune(features_segmentedS1, minvol=0.0001)
if(is.numeric(get_volume(features_segmentedS1))){
# GET HOLE PROPORTION = HOLE/TOTAL VOLUME
voldiffS1<-sum(get_volume(features_segmentedS1))/get_volume(hyperT)
volholeS1<-sum(get_volume(features_segmentedS1))
}
if(!is.numeric(get_volume(features_segmentedS1))){  voldiffS1<-0 ; volholeS1<-0 }

# plot vacant niche S1
n_segments <- length(features_segmentedS1@HVList)
plot(hypervolume_join(hyperT, features_segmentedS1), colors = c("black",rep("red",n_segments)), pairplot=F, showcentroid=F, cex.random=5, legend=F, contour.filled=T)
movie3d(spin3d(axis=c(0,0,1),rpm=5), duration = 15, movie="MovieS1", dir=getwd())

dev.off()

# calculate FD S2
hyperS2 <- hypervolume(traitS2, repsperpoint=1000, bandwidth = estimate_bandwidth(traits), verbose = F, warnings=F, quantile = 0.05)
FDTS2 <- get_volume(hyperS2)

# Simulate random extinctions for S1
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)
# calculate
FDTS2.null <- foreach(i=1:100, .combine='c', .packages='hypervolume') %dopar% { 
  get_volume(hypervolume(traits[sample(1:SPDTall, SPDTS2, replace = F),],
                         repsperpoint=1000, bandwidth = estimate_bandwidth(traits),
                         verbose = F, warnings=F, quantile = 0.05))
}
# stop the cluster
stopCluster(cl)

# Test if FD loss is higher or lower than random.
FDTS2.P <- t.test(FDTall-FDTS2.null, mu =  FDTall-FDTS2) # t.test

### Detect holes S2
# DETECT HOLES
featuresS2<-hypervolume_holes(hv_obs=hyperS2,hv_exp=hyperT,set_check_memory=F)
# CLEAN UP RESULTS
features_segmentedS2<-hypervolume_segment(featuresS2)
features_segmentedS2<-hypervolume_prune(features_segmentedS2, minvol=0.0001)
if(is.numeric(get_volume(features_segmentedS2))){
# GET HOLE PROPORTION = HOLE/TOTAL VOLUME
voldiffS2<-sum(get_volume(features_segmentedS2))/get_volume(hyperT)
volholeS2<-sum(get_volume(features_segmentedS2))
}
if(!is.numeric(get_volume(features_segmentedS2))){  voldiffS2<-0 ; volholeS2<-0 }

# plot vacant niche S2
n_segments <- length(features_segmentedS2@HVList)
plot(hypervolume_join(hyperT, features_segmentedS2), colors = c("black",rep("red",n_segments)), pairplot=F, showcentroid=F, cex.random=5, legend=F, contour.filled=T)
movie3d(spin3d(axis=c(0,0,1),rpm=5), duration = 15, movie="MovieS2", dir=getwd())

dev.off()
```

Total FD  
Controle: $`r round(FDTall,2)`$  
S1: $`r round(FDTS1,3)`$ ($`r round((FDTS1/FDTall)*100,1)`$% Total FD)  
S2: $`r round(FDTS2,3)`$ ($`r round((FDTS2/FDTall)*100,1)`$% Total FD)  

Total FD loss (FDall - FDScenario)  
S1: $`r round(FDTall-FDTS1,3)`$ ($`r round(((FDTall-FDTS1)/FDTall)*100,1)`$% Total FD) ; P-value = `r ifelse(FDTS1.P$p.value<0.001, "<0.001", "NS")`) ; Random expectation: Mean = $`r round(mean(FDTS1.null,3))`$, sd = $`r round(sd(FDTS1.null,3))`$.  
S2: $`r round(FDTall-FDTS2,3)`$ ($`r round(((FDTall-FDTS2)/FDTall)*100,1)`$% Total FD) ; P-value = `r ifelse(FDTS2.P$p.value<0.001, "<0.001", "NS")`) ; Random expectation: Mean = $`r round(mean(FDTS2.null,3))`$, sd = $`r round(sd(FDTS2.null,3))`$.    
    
Vacant niche analysis  
Hole fraction S1: $`r round(voldiffS1,2)*100`$% total volume  
Hole fraction S2: $`r round(voldiffS2,2)*100`$% total volume  
  
Figure. Observed vs random expectations for PD and FD-loss.   
```{r echo=F}
#pdf("FigA1_hist_PD_FD.pdf")

par(mfrow=c(2,2))
x<-density(PDTall-PDTS1.null)
plot(x, main="PD-loss optimistic",
xlim=c(min(c(PDTall-PDTS1,PDTall-PDTS1.null)), max(c(PDTall-PDTS1,PDTall-PDTS1.null))), xaxt="n")
polygon(x,col='gray')
axis(side=1, at=c(min(c(PDTall-PDTS1,PDTall-PDTS1.null)), max(c(PDTall-PDTS1,PDTall-PDTS1.null))))
abline(v = PDTall-PDTS1,  col = "red", lwd = 2)

x<-density(PDTall-PDTS2.null)
plot(x, main="PD-loss pessimistic",
xlim=c(min(c(PDTall-PDTS2,PDTall-PDTS2.null)), max(c(PDTall-PDTS2,PDTall-PDTS2.null))), xaxt="n")
polygon(x,col='gray')
axis(side=1, at=c(min(c(PDTall-PDTS2,PDTall-PDTS2.null)), max(c(PDTall-PDTS2,PDTall-PDTS2.null))))
abline(v = PDTall-PDTS2,  col = "red", lwd = 2)

x<-density(FDTall-FDTS1.null)
plot(x, main="FD-loss optimistic",
xlim=c(min(c(FDTall-FDTS1,FDTall-FDTS1.null)), max(c(FDTall-FDTS1,FDTall-FDTS1.null))), xaxt="n")
polygon(x,col='gray')
axis(side=1, at=c(min(c(FDTall-FDTS1,FDTall-FDTS1.null)), max(c(FDTall-FDTS1,FDTall-FDTS1.null))))
abline(v = FDTall-FDTS1,  col = "red", lwd = 2)

x<-density(FDTall-FDTS2.null)
plot(x, main="FD-loss pessimistic",
xlim=c(min(c(FDTall-FDTS2,FDTall-FDTS2.null)), max(c(FDTall-FDTS2,FDTall-FDTS2.null))), xaxt="n")
polygon(x,col='gray')
axis(side=1, at=c(min(c(FDTall-FDTS2,FDTall-FDTS2.null)), max(c(FDTall-FDTS2,FDTall-FDTS2.null))))
abline(v = FDTall-FDTS2,  col = "red", lwd = 2)

dev.off()

par(mfrow=c(1,1))
```

*** 

\newpage


# 2. Grid cell's analysis
## 2.1. Species richness
```{r eval = F}
#Controle
SPDall <- rowSums(occr)
# S1
SPDS1 <- rowSums(occrS1)
# S2
SPDS2 <- rowSums(occrS2)

# Species lost scenario 1
splossS1 <- SPDall-SPDS1
# Species lost scenario 2
splossS2 <- SPDall-SPDS2

# % SPD loss S1
p.splossS1 <- splossS1/SPDall*100
# % SPD loss S2
p.splossS2 <- splossS2/SPDall*100
```

## 2.2. Phylogenetic diversity (PD) loss
```{r eval = F}
###########################
### Control scenario

# set the cluster
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)
# calculate
NCell <- nrow(occr)
PDall <- foreach(i=1:NCell, .combine='c', .packages='ape') %dopar% { 
  # CALCULATE METRICS IF THERE ARE AT LEAST 3 SPECIES IN A COMMUNITY
  if(SPDall[i] < 3){  0  }
  else{ 
    tipnames <- names(occr)[which(!occr[i,]==1)]
    trx <- drop.tip(tree, tipnames) ;  sum(trx$edge.length)
  }
}
# stop the cluster
stopCluster(cl)

###########################
### Scenario 1

# Phylogenetic diversity
# set the cluster
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)
# calculate
NCell <- nrow(occrS1)
PDS1 <- foreach(i=1:NCell, .combine='c', .packages='ape') %dopar% { 
  # CALCULATE METRICS IF THERE ARE AT LEAST 3 SPECIES IN A COMMUNITY
  if(SPDS1[i] < 3){  PDall[i]  }
  else{ 
    tipnames <- names(occrS1)[which(occrS1[i,]==1)]
    trx <- drop.tip(tree, setdiff(tree$tip.label, tipnames))
    sum(trx$edge.length)
  }
}
# stop the cluster
stopCluster(cl)

# PD total loss scenario 1
PDlossS1 <- PDall-PDS1
# % PD remaining S1
p.PDlossS1 <- PDlossS1/PDall*100


# SES.PDS1 - test if PD loss is higher or lower than random
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)
NCell <- nrow(occrS1)
runs = 100

PDS1.null <- foreach(i=1:NCell, .combine='cbind', .packages=c('ape','picante')) %dopar% { 
  # CALCULATE ONLY IF THERE WERE LOST AT LEAST ONE SPECIES
  # CALCULATE METRICS IF THERE ARE AT LEAST 3 SPECIES IN A COMMUNITY
  if(any(splossS1[i]==0, SPDS1[i]<3)) { rep(PDall[i], runs) }
  else {
    replicate(runs, random.drop(SPDS1[i], occr[i,], tree))
  }
}
# stop the cluster
stopCluster(cl)

PDS1.null.loss <- data.frame(matrix(NA, nrow = nrow(PDS1.null), ncol = ncol(PDS1.null)))
for(i in 1:ncol(PDS1.null)){
  PDS1.null.loss[,i] <- PDall[i] - PDS1.null[,i]
}

PDS1.null.mean <- as.vector(apply(PDS1.null.loss, MARGIN = 2, FUN = mean, na.rm = TRUE))
PDS1.null.sd <- as.vector(apply(PDS1.null.loss, MARGIN = 2, FUN = sd, na.rm = TRUE))
PDS1.loss.ses <- (PDlossS1 - PDS1.null.mean)/PDS1.null.sd

PDS1.null.mean <- apply(PDS1.null, MARGIN = 2, FUN = mean, na.rm = TRUE)
PDS1.null.sd <- apply(PDS1.null, MARGIN = 2, FUN = sd, na.rm = TRUE)
PDS1.ses <- (PDS1 - PDS1.null.mean)/PDS1.null.sd


###########################
### Scenario 2

# Phylogenetic diversity
# set the cluster
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)
# calculate
NCell <- nrow(occrS2)
PDS2 <- foreach(i=1:NCell, .combine='c', .packages='ape') %dopar% { 
  # CALCULATE METRICS IF THERE ARE AT LEAST 3 SPECIES IN A COMMUNITY
  if(SPDS2[i] < 3){  PDall[i]  }
  else{ 
    tipnames <- names(occrS2)[which(occrS2[i,]==1)]
    trx <- drop.tip(tree, setdiff(tree$tip.label, tipnames))
    sum(trx$edge.length)  
  }
}
# stop the cluster
stopCluster(cl)

# PD total loss scenario 1
PDlossS2 <- PDall-PDS2
# % PD remaining S2
p.PDlossS2 <- PDlossS2/PDall*100


# SES.PDS2 - test if PD loss is higher or lower than random
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)
NCell <- nrow(occrS2)
runs = 100

PDS2.null <- foreach(i=1:NCell, .combine='cbind', .packages=c('ape','picante')) %dopar% { 
  # CALCULATE ONLY IF THERE WERE LOST AT LEAST ONE SPECIES
  # CALCULATE METRICS IF THERE ARE AT LEAST 3 SPECIES IN A COMMUNITY
  if(any(splossS2[i]==0, SPDS2[i]<3)) { rep(PDall[i], runs) }
  else {
    replicate(runs, random.drop(SPDS2[i], occr[i,], tree))
  }
}
# stop the cluster
stopCluster(cl)

PDS2.null.loss <- data.frame(matrix(NA, nrow = nrow(PDS2.null), ncol = ncol(PDS2.null)))
for(i in 1:ncol(PDS2.null)){
  PDS2.null.loss[,i] <- PDall[i] - PDS2.null[,i]
}

PDS2.null.mean <- as.vector(apply(PDS2.null.loss, MARGIN = 2, FUN = mean, na.rm = TRUE))
PDS2.null.sd <- as.vector(apply(PDS2.null.loss, MARGIN = 2, FUN = sd, na.rm = TRUE))
PDS2.loss.ses <- (PDlossS2 - PDS2.null.mean)/PDS2.null.sd

PDS2.null.mean <- apply(PDS2.null, MARGIN = 2, FUN = mean, na.rm = TRUE)
PDS2.null.sd <- apply(PDS2.null, MARGIN = 2, FUN = sd, na.rm = TRUE)
PDS2.ses <- (PDS2 - PDS2.null.mean)/PDS2.null.sd


```


```{r eval = F, echo = F}
# save image
save.image("PD+FD_erosion.RData")
```

## 2.3. Functional diversity (FD) loss
```{r eval = F}
# estimated bandwidths for each grid cell using the method of silverman
bandw.exp <- NA
for(i in 1:nrow(occr)){ cat("\r", i, "from", nrow(occr))
  tipnames <- names(occr)[which(occr[i,]==1)]
  bandw.exp[i] <- estimate_bandwidth(traits[tipnames,])
}

hist(bandw.exp)

plot(log(Rich),bandw.exp) # bandwidth is not associated with richness.

bandw <- median(bandw.exp)

save.image("PD+FD_erosion.RData")

###########################
### Control scenario

# set the cluster
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)
# calculate
NCell <- nrow(occr)
FDall <- foreach(i=1:NCell, .combine='c', .packages='hypervolume') %dopar% { 
  # CALCULATE METRICS IF THERE ARE AT LEAST 3 SPECIES IN A COMMUNITY
  if(SPDall[i] < 3){  0  }
  else{ 
    tipnames <- names(occr)[which(occr[i,]==1)]
    tmp<-hypervolume(traits[tipnames,], bandwidth = bandw, verbose = F, warnings=F,
                     quantile = 0.05)
    get_volume(tmp)
  }
}
# stop the cluster
stopCluster(cl)


###########################
### Scenario 1

# Functional diversity
# set the cluster
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)
# calculate
NCell <- nrow(occr)
FDS1 <- foreach(i=1:NCell, .combine='c', .packages='hypervolume') %dopar% { 
  # CALCULATE METRICS IF THERE ARE AT LEAST 3 SPECIES IN A COMMUNITY
  if(SPDS1[i] < 3){  FDall[i]  }
  else{
  tipnames <- names(occrS1)[which(occrS1[i,]==1)]
  tmpS<-hypervolume(traitS1[tipnames,], bandwidth = bandw, verbose = F, warnings=F,
                    quantile = 0.05)
  get_volume(tmpS)
  }
}
# stop the cluster
stopCluster(cl)

# FD total loss scenario 1
FDlossS1 <- FDall-FDS1
# % FD remaining S1
p.FDlossS1 <- FDlossS1/FDall*100


# Hole fraction
# set the cluster
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)
# calculate
NCell <- nrow(occrS1)
HoleS1 <- foreach(i=1:NCell, .combine='c', .packages='hypervolume') %dopar% { 
  # CALCULATE ONLY IF THERE WERE LOST AT LEAST ONE SPECIES. 
  # CALCULATE METRICS IF THERE ARE AT LEAST 3 SPECIES IN A COMMUNITY
  if(any(splossS1[i]==0, SPDS1[i]<3)) { 0 }
  else{
    # HYPERVOLUME CONTROL
    tipnames <- names(occr)[which(occr[i,]==1)]
    tmp<-hypervolume(traits[tipnames,], bandwidth = bandw, verbose = F, warnings=F,
                     quantile = 0.05)
    # HYPERVOLUME SCENARIO
    tipnames <- names(occrS1)[which(occrS1[i,]==1)]
    tmpS<-hypervolume(traitS1[tipnames,], bandwidth = bandw, verbose = F, warnings=F,
                      quantile = 0.05)
    vol <- get_volume(tmpS)
    # DETECT HOLES (low npoints for fast execution)
    features <- hypervolume_holes(hv_obs=tmpS,hv_exp=tmp,set_check_memory=F)
    features_segmented <- hypervolume_segment(features)
    if(is.numeric(get_volume(features_segmented))){
      # CALCULATE HOLE FRACTION
      sum(get_volume(features_segmented))/get_volume(tmp)
    } 
    else { 0 }
  }
}
# stop the cluster
stopCluster(cl)

# Fix zero Holes when SPDS[i]<3 - In this case the hole should be NA because metrics are calculate only if there are at least 3 species in a community
HoleS1[which(SPDS1<3)] <- NA


# SES.FDS1 - test if FD loss is higher or lower than random
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)
NCell <- nrow(occrS1)
runs = 100
FDS1.null <- foreach(i=1:NCell, .combine='cbind', .packages=c('hypervolume')) %dopar% { 
  # CALCULATE ONLY IF THERE WERE LOST AT LEAST ONE SPECIES. 
  # CALCULATE METRICS IF THERE ARE AT LEAST 3 SPECIES IN A COMMUNITY
  if(any(splossS1[i]==0, SPDS1[i]<3)) {  rep(FDall[i], runs) }
  else {
    replicate(runs, random.fd(SPDS1[i], occr, traits))
  }
}
# stop the cluster
stopCluster(cl)

FDS1.null.loss <- data.frame(matrix(NA, nrow = nrow(FDS1.null), ncol = ncol(FDS1.null)))
for(i in 1:ncol(FDS1.null)){
  FDS1.null.loss[,i] <- FDall[i] - FDS1.null[,i]
}

FDS1.null.mean <- apply(FDS1.null.loss, MARGIN = 2, FUN = mean, na.rm = TRUE)
FDS1.null.sd <- apply(FDS1.null.loss, MARGIN = 2, FUN = sd, na.rm = TRUE)
FDS1.loss.ses <- (FDlossS1 - FDS1.null.mean)/FDS1.null.sd
FDS1.loss.ses[is.nan(FDS1.loss.ses)] <- NA

FDS1.null.mean <- apply(FDS1.null, MARGIN = 2, FUN = mean, na.rm = TRUE)
FDS1.null.sd <- apply(FDS1.null, MARGIN = 2, FUN = sd, na.rm = TRUE)
FDS1.ses <- (FDS1 - FDS1.null.mean)/FDS1.null.sd
FDS1.ses[is.nan(FDS1.ses)] <- NA


###########################
### Scenario 2

# Functional diversity
# set the cluster
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)
# calculate
NCell <- nrow(occr)
FDS2 <- foreach(i=1:NCell, .combine='c', .packages='hypervolume') %dopar% { 
  # CALCULATE METRICS IF THERE ARE AT LEAST 3 SPECIES IN A COMMUNITY
  if(SPDS2[i] < 2){  FDall[i]  }
  else{
  tipnames <- names(occrS2)[which(occrS2[i,]==1)]
  tmpS<-hypervolume(traitS2[tipnames,], bandwidth = bandw, verbose = F, warnings=F,
                    quantile = 0.05)
  get_volume(tmpS)
  }
}
# stop the cluster
stopCluster(cl)

# FD total loss scenario 1
FDlossS2 <- FDall-FDS2
# % FD remaining S2
p.FDlossS2 <- FDlossS2/FDall*100


# Hole fraction
# set the cluster
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)
# calculate
NCell <- nrow(occrS2)
HoleS2 <- foreach(i=1:NCell, .combine='c', .packages='hypervolume') %dopar% { 
  # CALCULATE ONLY IF THERE WERE LOST AT LEAST ONE SPECIES. 
  # CALCULATE METRICS IF THERE ARE AT LEAST 3 SPECIES IN A COMMUNITY
  if(any(splossS2[i]==0, SPDS2[i]<3)) { 0 }
  else{
    # HYPERVOLUME CONTROL
    tipnames <- names(occr)[which(occr[i,]==1)]
    tmp<-hypervolume(traits[tipnames,], bandwidth = bandw, verbose = F, warnings=F,
                     quantile = 0.05)
    # HYPERVOLUME SCENARIO
    tipnames <- names(occrS2)[which(occrS2[i,]==1)]
    tmpS<-hypervolume(traitS2[tipnames,], bandwidth = bandw, verbose = F, warnings=F,
                      quantile = 0.05)
    vol <- get_volume(tmpS)
    # DETECT HOLES (low npoints for fast execution)
    features <- hypervolume_holes(hv_obs=tmpS,hv_exp=tmp,set_check_memory=F)
    features_segmented <- hypervolume_segment(features)
    if(is.numeric(get_volume(features_segmented))){
      # CALCULATE HOLE FRACTION
      sum(get_volume(features_segmented))/get_volume(tmp)
    } 
    else { 0 }
  }
}
# stop the cluster
stopCluster(cl)

# Fix zero Holes when SPDS[i]<3 - In this case the hole should be NA because metrics are calculate only if there are at least 3 species in a community
HoleS2[which(SPDS2<3)] <- NA


# SES.FDS2 - test if FD loss is higher or lower than random
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)
NCell <- nrow(occrS2)
runs = 100
FDS2.null <- foreach(i=1:NCell, .combine='cbind', .packages=c('hypervolume')) %dopar% { 
  # CALCULATE ONLY IF THERE WERE LOST AT LEAST ONE SPECIES. 
  # CALCULATE METRICS IF THERE ARE AT LEAST 3 SPECIES IN A COMMUNITY
  if(any(splossS2[i]==0, SPDS2[i]<3)) {  rep(FDall[i], runs) }
  else {
    replicate(runs, random.fd(SPDS2[i], occr, traits))
  }
}
# stop the cluster
stopCluster(cl)

FDS2.null.loss <- data.frame(matrix(NA, nrow = nrow(FDS2.null), ncol = ncol(FDS2.null)))
for(i in 1:ncol(FDS2.null)){
  FDS2.null.loss[,i] <- FDall[i] - FDS2.null[,i]
}

FDS2.null.mean <- apply(FDS2.null.loss, MARGIN = 2, FUN = mean, na.rm = TRUE)
FDS2.null.sd <- apply(FDS2.null.loss, MARGIN = 2, FUN = sd, na.rm = TRUE)
FDS2.loss.ses <- (FDlossS2 - FDS2.null.mean)/FDS2.null.sd
FDS2.loss.ses[is.nan(FDS2.loss.ses)] <- NA

FDS2.null.mean <- apply(FDS2.null, MARGIN = 2, FUN = mean, na.rm = TRUE)
FDS2.null.sd <- apply(FDS2.null, MARGIN = 2, FUN = sd, na.rm = TRUE)
FDS2.ses <- (FDS2 - FDS2.null.mean)/FDS2.null.sd
FDS2.ses[is.nan(FDS2.ses)] <- NA


```


```{r eval = F, echo = F}
# save image
save.image("PD+FD_erosion.RData")
```

*** 

\newpage

# 4. Plot maps of diversity-loss  

Figure. Actual diversity pattern.    
```{r echo=F, results="hide"}
#X11(width = 5.5, height = 5)
#pdf("FigA3_Control.pdf", width = 5, height = 5)
#png("FigA3_Control.png", width = 5.5, height = 5, units = "in",res = 300)
layout(matrix(c(1,2,3), byrow = F))
par(mar=c(1,0,1,1))

rampa <- colorRampPalette(c('blue','yellow','red'))(41)

# Get class intervals SPD
SR_classint <- BAMMtools::getJenksBreaks(SPDall, 40)
# avoid identical breaks
SR_classint <- unique(SR_classint)
# Get class intervals PD
PD_classint <- BAMMtools::getJenksBreaks(PDall, 40)
# avoid identical breaks
PD_classint <- unique(PD_classint)
# Get class intervals FD
FD_classint <- BAMMtools::getJenksBreaks(FDall, 40)
# avoid identical breaks
FD_classint <- unique(FD_classint)


# total richness
SR <- cbind(data.frame(XY),Var=SPDall)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR,main='Richness',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR,add=T,main='Richness',axes=F,box=F, axis.args=list(at=round(func_splint(SPDall,5),0), labels=round(func_splint(SPDall,5),0)), breaks = SR_classint, col=rampa)
plot(mundi, axes = F, add=T)

# Total PD
SR <- cbind(data.frame(XY),Var=PDall)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR,main='Phylogenetic diversity',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR,add=T,axes=F,box=F, axis.args=list(at=func_splint(PDall,5), labels=round(func_splint(PDall,5),2)), breaks = PD_classint, col=rampa)
plot(mundi, axes = F, add=T)

# Total FD
SR <- cbind(data.frame(XY),Var=FDall)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR,main='Functional diversity',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR,add=T,axes=F,box=F, axis.args=list(at=func_splint(FDall,5), labels=round(func_splint(FDall,5),2)), breaks = FD_classint, col=rampa)
plot(mundi, axes = F, add=T)

dev.off()
```

*** 

\newpage

Figure. % species loss 
```{r echo=F, results="hide"}
#X11(width = 5.5, height = 5)
#pdf("Fig1.pdf", width = 5, height = 5)
png("Fig1_SPDloss.png", width = 5.5, height = 5, units = "in",res = 300)
layout(matrix(c(1,2), byrow = F))
par(mar=c(1,0,1,1))

# Get class intervals SPD S1
#SRS1_classint <- BAMMtools::getJenksBreaks(p.splossS1, 40)
# avoid identical breaks
#SRS1_classint <- unique(SRS1_classint)
# Get class intervals SPD S2
#SRS2_classint <- BAMMtools::getJenksBreaks(p.splossS2, 40)
# avoid identical breaks
#SRS2_classint <- unique(SRS2_classint)


# SPD loss S1
SR <- cbind(data.frame(XY),Var=p.splossS1)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR,main='% Threatenead species',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR, add=T, main='',  col=colorRampPalette(c('darkblue','yellow','red'))(5))
plot(mundi, axes = F, add=T)

# SPD loss S2
SR <- cbind(data.frame(XY),Var=p.splossS2)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR,main='',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR, add=T, main='',  col=colorRampPalette(c('darkblue','yellow','red'))(5))
plot(mundi, axes = F, add=T)

# Plot the histogram as inset 
#   x_left, x_right, y_bottom, y_top are portions of the main chart X and Y spans.
par(fig=c(0.07, 0.24, 0.55, 0.8), new=T, las=1, ps=7)
hist(p.splossS1,main="",ylab=NULL,xlab="")
# Plot the histogram as inset 
#   x_left, x_right, y_bottom, y_top are portions of the main chart X and Y spans.
par(fig=c(0.07, 0.24, 0.05, 0.30), new=T, las=1, ps=7)
hist(p.splossS2,main="",ylab=" ",xlab=" ")

dev.off()
```


- How many assemblages didnt lost species in S1?  
`r (length(which(p.splossS1==0))/nrow(occr))*100`%  
- How many assemblages will lost species in S2?  
`r (length(which(p.splossS2==0))/nrow(occr))*100`%  

- How many assemblages will lost species in S1?  
`r (length(which(p.splossS1>1))/nrow(occr))*100`%  
- How many assemblages will lost species in S2?  
`r (length(which(p.splossS2>1))/nrow(occr))*100`%  

- The majority of assemblages will lost this % of species in S1:  
` r median(p.splossS1)`  
- The majority of assemblages will lost this % of species in S2:  
` r median(p.splossS2)`  

- Around `r (length(which(p.splossS1>40 & p.splossS1<60))/nrow(occr))*100`% of all assemblages will experience a loss of species of between 40 and 60%

- Around `r (length(which(p.splossS2>40 & p.splossS2<60))/nrow(occr))*100`% of all assemblages will experience a loss of species of between 40 and 60%  

- From species-rich regions (SR>40), how many species are expected to be loss?  
S1: `r mean(p.splossS1[which(SPDall>40)])`  
S2: `r mean(p.splossS2[which(SPDall>40)])`




*** 

\newpage

Figure. PD loss
```{r echo=F, results="hide"}
#X11(width = 5.5, height = 5)
#pdf("PD_loss.pdf", width = 5.5, height = 5)
png("Fig2_PD_loss.png", width = 5.5, height = 5, units = "in",res = 300)
layout(matrix(c(1,2), byrow = F))
par(mar=c(1,0,1,1))

rem1 <- which(PDS1.loss.ses > 5)
PDS1.loss.ses2 <- PDS1.loss.ses[-rem1]
rem2 <- which(PDS2.loss.ses > 5)
PDS2.loss.ses2 <- PDS2.loss.ses[-rem2]

max_abolute_PDS1 <- max(abs(c(na.omit(PDS1.loss.ses2[!is.infinite(PDS1.loss.ses2)]))))
max_abolute_PDS2 <- max(abs(c(na.omit(PDS2.loss.ses2[!is.infinite(PDS2.loss.ses2)]))))

brkS1 <- round(func_splint(c(-max_abolute_PDS1,max_abolute_PDS1),6),1)
brkS2 <- round(func_splint(c(-max_abolute_PDS2,max_abolute_PDS2),6),1)

# PD loss
SR <- cbind(data.frame(XY[-rem1,]),Var=PDS1.loss.ses2)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR, main='SES PD-loss',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR, add=T, main='',axes=F, breaks=brkS1, zlim=c(-max_abolute_PDS1,max_abolute_PDS1), box=F, col=colorRampPalette(c('darkblue','white','red'))(5))
plot(mundi, axes = F, add=T)

# PD loss
SR <- cbind(data.frame(XY[-rem2,]),Var=PDS2.loss.ses2)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR, main='',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR, add=T, main='',axes=F, breaks=brkS2, zlim=c(-max_abolute_PDS2,max_abolute_PDS2), box=F, col=colorRampPalette(c('darkblue','white','red'))(5))
plot(mundi, axes = F, add=T)

# Plot the histogram as inset 
#   x_left, x_right, y_bottom, y_top are portions of the main chart X and Y spans.
par(fig=c(0.07, 0.24, 0.55, 0.8), new=T, las=1, ps=7)
hist(PDS1.loss.ses2,main="",ylab=NULL,xlab="")
# Plot the histogram as inset 
#   x_left, x_right, y_bottom, y_top are portions of the main chart X and Y spans.
par(fig=c(0.07, 0.24, 0.05, 0.30), new=T, las=1, ps=7)
hist(PDS2.loss.ses2,main="",ylab=" ",xlab=" ")

dev.off()
```

- How much assemblage will not loose more or less species than expected by random?
S1: `r (length(which(PDS1.loss.ses2>-1 & PDS1.loss.ses2 <1))/length(na.omit(PDS1.loss.ses2)))*100`%  
S2: `r (length(which(PDS2.loss.ses2>-1 & PDS2.loss.ses2 <1))/length(na.omit(PDS2.loss.ses2)))*100`

- How much positive and negative SES?
S1: 
Positive: `r (length(which(na.omit(PDS1.loss.ses2)>0))/length(na.omit(PDS1.loss.ses2)))*100`%  
Negative: `r (length(which(na.omit(PDS2.loss.ses2)<0))/length(na.omit(PDS2.loss.ses2)))*100`%  
S2: Positive: `r (length(which(na.omit(PDS2.loss.ses2)>0))/length(na.omit(PDS2.loss.ses2)))*100`%  
Negative: `r (length(which(na.omit(PDS2.loss.ses2)<0))/length(na.omit(PDS2.loss.ses2)))*100`%  

*** 

\newpage
Figure. FD loss
```{r echo=F, results="hide"}
#pdf("FD_loss.pdf", width = 5.5, height = 5)
png("Fig3_FD_loss.png", width = 5.5, height = 5, units = "in",res = 300)
layout(matrix(c(1,2), byrow = F))
par(mar=c(1,0,1,1))

max_abolute_FDS1 <- max(abs(c(na.omit(FDS1.loss.ses[!is.infinite(FDS1.loss.ses)]))))
max_abolute_FDS2 <- max(abs(c(na.omit(FDS2.loss.ses[!is.infinite(FDS2.loss.ses)]))))

brkS1 <- round(func_splint(c(-max_abolute_FDS1,max_abolute_FDS1),6),1)
brkS2 <- round(func_splint(c(-max_abolute_FDS2,max_abolute_FDS2),6),1)

# FD loss
SR <- cbind(data.frame(XY),Var=FDS1.loss.ses)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR, main='SES FD-loss',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR, add=T, main='',axes=F, breaks=brkS1, zlim=c(-max_abolute_FDS1,max_abolute_FDS1), box=F, col=colorRampPalette(c('darkblue','white','red'))(5))
plot(mundi, axes = F, add=T)

# FD loss
SR <- cbind(data.frame(XY),Var=FDS2.loss.ses)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR, main='',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR, add=T, main='',axes=F, breaks=brkS2, zlim=c(-max_abolute_FDS2,max_abolute_FDS2), box=F, col=colorRampPalette(c('darkblue','white','red'))(5))
plot(mundi, axes = F, add=T)

# Plot the histogram as inset 
#   x_left, x_right, y_bottom, y_top are portions of the main chart X and Y spans.
par(fig=c(0.07, 0.24, 0.55, 0.8), new=T, las=1, ps=7)
hist(FDS1.loss.ses,main="",ylab=NULL,xlab="")
# Plot the histogram as inset 
#   x_left, x_right, y_bottom, y_top are portions of the main chart X and Y spans.
par(fig=c(0.07, 0.24, 0.05, 0.30), new=T, las=1, ps=7)
hist(FDS2.loss.ses,main="",ylab=" ",xlab=" ")


dev.off()
```

*** 

\newpage

Figure. Vacant niche analysis. Values represent the ratio between the volume of the detected hole and the total volume of a niche space (V~hole~/V~total~).
```{r echo=F, results="hide"}
#X11(width = 5.5, height = 3.33)
#png("Fig4_HoleFig.png", width = 5.5, height = 5, units = "in",res = 300)
layout(matrix(c(1,2), byrow = F))
par(mar=c(1,0,1,1))

# Get class intervals Hole 1
#H1_classint <- round(BAMMtools::getJenksBreaks(HoleS1, 5),1)
# avoid identical breaks
#H1_classint <- unique(H1_classint)
# Get class intervals Hole 2
#H2_classint <- BAMMtools::getJenksBreaks(HoleS2, 5)
# avoid identical breaks
#H2_classint <- unique(H2_classint)

max_abolute_HS1 <- max(abs(c(na.omit(HoleS1[!is.infinite(HoleS1)]))))
max_abolute_HS2 <- max(abs(c(na.omit(HoleS2[!is.infinite(HoleS2)]))))

brkS1 <- round(func_splint(c(0,max_abolute_HS1),6),2)
brkS2 <- round(func_splint(c(0,max_abolute_HS2),6),2)

# Hole S1
SR <- cbind(data.frame(XY),Var=HoleS1)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR, main=expression('Hole fraction (V'[hole]*'/V'[total]*')'),axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR, add=T, main='',axes=F, box=F, breaks = brkS1,
     col=colorRampPalette(c('blue','yellow','red'))(5))
plot(mundi, axes = F, add=T)

# Hole S2
SR <- cbind(data.frame(XY),Var=HoleS2)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR, main="",axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR, add=T, main='',axes=F, box=F, breaks = brkS2,
     col=colorRampPalette(c('blue','yellow','red'))(5))
plot(mundi, axes = F, add=T)

# Plot the histogram as inset 
#   x_left, x_right, y_bottom, y_top are portions of the main chart X and Y spans.
par(fig=c(0.07, 0.24, 0.55, 0.8), new=T, las=1, ps=7)
hist(HoleS1,main="",ylab=NULL,xlab="")
# Plot the histogram as inset 
#   x_left, x_right, y_bottom, y_top are portions of the main chart X and Y spans.
par(fig=c(0.07, 0.24, 0.05, 0.30), new=T, las=1, ps=7)
hist(HoleS2,main="",ylab=" ",xlab=" ")

#expression('Hole fraction (V'[hole]*'/V'[total]*')')
dev.off()
```

- Hole size distribution?  
S1:   
Small: <10% = `r (length(which(HoleS1<.13))/length(na.omit(SPDS1)))*100`%
Large: >30% = `r (length(which(HoleS1>.13))/length(na.omit(SPDS1)))*100`%
median: `r mean(na.omit(HoleS1))`

S2: `r (length(which(HoleS2>.4))/length(SPDS2))*100`
median: `r mean(na.omit(HoleS2))`

- Does hole fraction correlate with sp loss fraction?  
S1: `r summary(lm(HoleS1~p.splossS1))` 
S2: `r summary(lm(HoleS2~p.splossS2))` 

```{r echo=F, eval=F}
pdf("dimensions_S1.pdf", width = 8.5, height = 11/3)
pairs(cbind(Rich=log(splossS1+1),PD=log(PDlossS1+1),FD=log(FDlossS1+1)), lower.panel=panel.smooth, upper.panel=panel.cor,diag.panel=panel.hist)
dev.off()

```

```{r echo=F, eval=F}
pdf("dimensions_S2.pdf", width = 8.5, height = 11/3)
pairs(cbind(Rich=log(splossS2+1),PD=log(PDlossS2+1),FD=log(FDlossS2+1)), lower.panel=panel.smooth, upper.panel=panel.cor,diag.panel=panel.hist)
dev.off()

```

END OF CODE