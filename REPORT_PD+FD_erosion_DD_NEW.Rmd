---
title: "Erosion of phylogenetic and functional diversity in Amphibians"
author: "Brunno F Oliveira^1^; Gabriel C Costa^1^"
date: "October 20, 2015\n**1** Programa de Pós-graduação em Ecologia, Universidade
  Federal do Rio Grande do Norte, Lagoa Nova, 59072-970, Natal, RN, Brazil. **Corresponding
  author:** (brunno.oliveira@me.com) "
output: pdf_document
theme: united
toc: yes
---

*** 

\newpage


Packages versions:
```{r info, message=FALSE, echo=F}
info <- sessionInfo()
```

# Load packages
We used `r info[1]$R$ver` and the following packages:
```{r packages, message=FALSE}
rm(list=ls())
gc()

list.of.packages <- c("rmarkdown","sp","rgdal","raster","maps","maptools","rgeos","raster","stringr","picante","ape","rgdal","ggplot2","geiger","ade4","foreach","parallel","doParallel","PBSmapping","nabor","plot3D","knitr","vegan","phytools","rworldmap","FD","hypervolume","BAMMtools","spdep","fmsb","ncf","cowplot","classInt","colorplaner","MuMIn","plyr","dplyr","doSNOW","pbapply","ggpubr","reshape","diversitree","rredlist", "XML","spatialreg")

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

sapply(list.of.packages, require, character.only = TRUE)
```

#Load data
```{r echo=F}
setwd("C:/Users/boliveir/Dropbox (UFL)/Extinction PD-FD-loss/R_code_new")
knitr::opts_knit$set(
  root.dir = "C:/Users/boliveir/Dropbox (UFL)/Extinction PD-FD-loss/R_code_new")

# load this if you running the code for the first time
# load("PD+FD_erosion_get_data_DD_new.RData")
# load("PD+FD_erosion_getdata.RData")

olddata <- read.csv("dataset_old.csv")
traits_old <- read.csv("traits2_old.csv")
occr_old <- read.csv("occr_old.csv")

# load this if you have already done the job
load("PD+FD_erosion_new.RData")

```


# Land data
```{r , echo=F}
mundi <- rgdal::readOGR("G:/GIS/Shp files/ne_50m_land/ne_50m_land_no_artic.shp")
crs(mundi) <-"+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 "
mundi <- spTransform(mundi, CRS("+proj=cea +datum=WGS84"))

# REFERENCE PROJECTION MAP
mapa <- raster(xmn = -20592508, xmx = 20588492, ymn = -5743602, ymx = 6573398,
              crs = CRS("+proj=cea +datum=WGS84"))
res(mapa) <- 111000
```

# Load functions
```{r eval = F}
source("TreePlotsSource.R")
#### Bivariate maps
#function to generate bivariate maps. Copy and paste that into R:
bivariate.map<-function(rasterx, rastery, colormatrix=col.matrix, nquantiles=10){
  quanmean<-getValues(rasterx)
  temp <- data.frame(quanmean, quantile=rep(NA, length(quanmean)))
  brks <- with(temp, quantile(temp,na.rm=TRUE, probs = c(seq(0,1,1/nquantiles))))
  r1 <- within(temp, quantile <- cut(quanmean, breaks = brks, labels = 2:length(brks),include.lowest = TRUE))
  quantr<-data.frame(r1[,2]) 
  quanvar<-getValues(rastery)
  temp <- data.frame(quanvar, quantile=rep(NA, length(quanvar)))
  brks <- with(temp, quantile(temp,na.rm=TRUE, probs = c(seq(0,1,1/nquantiles))))
  r2 <- within(temp, quantile <- cut(quanvar, breaks = brks, labels = 2:length(brks),include.lowest = TRUE))
  quantr2<-data.frame(r2[,2])
  as.numeric.factor <- function(x) {as.numeric(levels(x))[x]}
  col.matrix2<-colormatrix
  cn<-unique(colormatrix)
  for(i in 1:length(col.matrix2)){
    ifelse(is.na(col.matrix2[i]),col.matrix2[i]<-1,col.matrix2[i]<-which(col.matrix2[i]==cn)[1])}
  cols<-numeric(length(quantr[,1]))
  for(i in 1:length(quantr[,1])){
    a<-as.numeric.factor(quantr[i,1])
    b<-as.numeric.factor(quantr2[i,1])
    cols[i]<-as.numeric(col.matrix2[b,a])}
  r<-rasterx
  r[1:length(r)]<-cols
  return(r)}

colmat<-function(nquantiles=10, 
                 upperleft=rgb(0,150,235, maxColorValue=255), 
                 upperright=rgb(130,0,80, maxColorValue=255), 
                 bottomleft="grey", bottomright=rgb(255,230,15, maxColorValue=255), 
                 xlab="x label", ylab="y label",
                 .plot=T){
  my.data<-seq(0,1,.01)
  my.class<-classIntervals(my.data,n=nquantiles,style="quantile")
  my.pal.1<-findColours(my.class,c(upperleft,bottomleft))
  my.pal.2<-findColours(my.class,c(upperright, bottomright))
  col.matrix<-matrix(nrow = 101, ncol = 101, NA)
  for(i in 1:101){
    my.col<-c(paste(my.pal.1[i]),paste(my.pal.2[i]))
    col.matrix[102-i,]<-findColours(my.class,my.col)}
  if(.plot==T){
    plot(c(1,1),pch=19,col=my.pal.1, cex=0.5,xlim=c(0,1),ylim=c(0,1),frame.plot=F, xlab=xlab, ylab=ylab,cex.lab=1.3)
  for(i in 1:101){
    col.temp<-col.matrix[i-1,]
    points(my.data,rep((i-1)/100,101),pch=15,col=col.temp, cex=1)}}
  seqs<-seq(0,100,(100/nquantiles))
  seqs[1]<-1
  col.matrix <- col.matrix[c(seqs), c(seqs)]}



# Get simbols to p-significances
ps <- function(x){
  res <- rep(NA, length(x))
  res[which(x<=0.05)] <- "*"
  res[which(x<=0.01)] <- "**"
  res[which(x<=0.005)] <- "***"
  res[which(x>0.05)] <- "NS"
  return(res)
}

range01 <- function(x){(x-min(x,na.rm = T))/(max(x,na.rm = T)-min(x,na.rm = T))}

# get percentile of number 
ecdf_fun <- function(x,perc) ecdf(x)(perc)

#### function to get equal binds from a vector
func_splint <- function(x,intervals=4) {
  seq(min(x,na.rm = T),max(x,na.rm = T),length.out=intervals)
}

iucn_token <- "72384daa25849d16f97b3b180783680b4d9492b51a64565fdfefbebec7de6cfe"

b.accepted.name <- function(input) {
  
  h <- try(htmlParse(paste("http://apiv3.iucnredlist.org/api/v3/species/synonym/",
                           input, "?token=", iucn_token,sep = "")), silent = TRUE)
  h <- as(h, "character")
  
  h2 <- gsub('^.*"accepted_name":\\s*|\\s*,.*$', '', h)
  h2 <- gsub("\"", '', h2, fixed = TRUE)
  
  return(h2)
}

b.accepted.name2 <- function(input) {
  
  h <- try(htmlParse(paste("http://apiv3.iucnredlist.org/api/v3/species/id/",
                           input, "?token=", iucn_token,sep = "")), silent = TRUE)
  h <- as(h, "character")
  
  h2 <- gsub('^.*"scientific_name":\\s*|\\s*,.*$', '', h)
  h2 <- gsub("\"", '', h2, fixed = TRUE)
  
  return(h2)
}

# Function for calculating PD from a list of species
# sps = list of species
# phy = phylogeny
# minsp = mininum N species for calculationg PD
PD_from_list <- function(sps, phy, minsp=3){
  # build tree with species
  if(length(sps) < minsp){  NA  }
  else{
    tips <- as.character(phy$tip.label)
    trx <- drop.tip(phy, as.character(tips[-which(tips %in% sps)]))
    # calculate PD
    return(sum(trx$edge.length))
  }
}

# calculates PD from a randon selection of n species from the given species pool
# pool = species pool from which to sample
# n = n species to sample
# phy = phylogenetic tree used for calculating PD
# random = optional. n times for replicate the random sample
# internal function for PD_from_random
PD_random <- function(pool, n, phy){
  # random sample n species from the pool
  sp.tmp <- pool[sample(1:length(pool), n, replace = F)]
  # build tree with this random species
  trx <- drop.tip(phy, as.character(phy$tip.label[-which(phy$tip.label %in% sp.tmp)]))
  # calculate PD
  return(sum(trx$edge.length))
}
PD_from_random <- function(pool, n, phy, runs=1){
  if(runs<1){cat("ERROR: 'run' has to be higher than 1") ; stop()}
  if(n < 3) { return(rep(NA, runs)) } # do not calculate PD for less than 3 species
  else{
    if (length(pool) == 0) { return(rep(NA, runs)) }
    else{
      replicate(runs, PD_random(pool, n, phy))
    }
  }
}

# shuffles probabilities, select species based on shuffled probabilities and calculate PD
# this function keeps severity in extinction
PD_from_prob <- function(probs, sps, phy, runs=1, minsp=3){
  # build tree with species
  if(length(sps) < minsp){  rep(NA,runs)  }
  else{
    probs <- probs[which(probs$Species %in% sps_i),c(-1:-3)]
    probs <- probs[shuffle(probs),]
    
    PD.tmp <- apply(probs, 2, function(x)  
      
      PD_from_list(sps[which(x==1)], tree))
    
    return(PD.tmp)
  }
}

# shuffles probabilities, select species based on shuffled probabilities and calculate PD
PD_from_prob_backup <- function(probs, sps, phy, runs=1, minsp=3){
  # build tree with species
  if(length(sps) < minsp){  rep(NA,runs)  }
  else{
    
    sps_sim <- replicate(runs, # null future species based on ...
                         rbinom(sps, # this list of species
                                1, # one coint tossed (no need for more because we are replicating above)
                                probs[shuffle(probs)])) # these survivor probabilities 
    
    # return(sps_sim)
    
    PD.tmp <- apply(sps_sim, 2, function(x)  
      
      PD_from_list(sps[which(x==1)], tree))
    
    return(PD.tmp)
  }
}


# Function for calculating FD from a list of species
# sps = list of species
# traitdata = trait data
# minsp = mininum N species for calculationg FD
# bd = bandwidth
FD_from_list <- function(sps, traitdata, bd, minsp=3, get_volume = T, samples.per.point = 100){
  # build tree with species
  if(length(sps) < minsp){  NA  }
  else{
    td <- traitdata[which(rownames(traitdata) %in% sps),]
    # calculate FD
    FD_tmp <- hypervolume_gaussian(data=td, 
                                   samples.per.point = samples.per.point,
                                   kde.bandwidth = bd,
                                   verbose = F)
    if(get_volume == T){
      return(get_volume(FD_tmp))
    }
    if(get_volume == F){
      return(FD_tmp)
    }
  }
}

# shuffles probabilities, select species based on shuffled probabilities and calculate FD
FD_from_prob <- function(probs, sps, traitdata, bd, get_volume = T, samples.per.point = 100, runs=1,minsp=3){
  # build tree with species
  if(length(sps) < minsp){  rep(NA,runs)  }
  else{
    
    probs <- probs[which(probs$Species %in% sps_i),c(-1:-3)]
    probs <- probs[shuffle(probs),]
    
    FD.tmp <- apply(probs, 2, function(x)
      
      FD_from_list(sps = sps[which(x==1)], 
                   traitdata = traitdata, 
                   samples.per.point = 100,
                   bd = bd,
                   get_volume = F))
    
    return(FD.tmp)
    
  }
}

# shuffles probabilities, select species based on shuffled probabilities and calculate FD
FD_from_prob_backup <- function(probs, sps, traitdata, bd, get_volume = T, samples.per.point = 100, runs=1,minsp=3){
  # build tree with species
  if(length(sps) < minsp){  rep(NA,runs)  }
  else{
    
    sps_sim <- replicate(runs, # null future species based on ...
                         rbinom(sps, # this list of species
                                1, # one coint tossed (no need for more because we are replicating above)
                                probs[shuffle(probs)])) # these survivor probabilities 
    
    # return(sps_sim)
    
    FD.tmp <- apply(sps_sim, 2, function(x)
      
      FD_from_list(sps = sps[which(x==1)], 
                   traitdata = traitdata, 
                   samples.per.point = 100,
                   bd = bd,
                   get_volume = F))
    
    return(FD.tmp)
    
  }
}

# calculates FD from a randon selection of n species from the given list of species
# pool = species pool from which to sample
# n = n species to sample
# traitdata = trait data
# bd = bandwidth
# internal function for FD_from_random
FD_random <- function(pool, n, traitdata, bd, get_volume = T, samples.per.point = 100){
  # random sample n species from the pool
  sp.tmp <- pool[sample(1:length(pool), n, replace = F)]
  # build traitdata with this random species
  traitdata_tmp <- traitdata[which(rownames(traitdata) %in% sp.tmp),]
  # calculate FD
  FD_tmp <- hypervolume_gaussian(data=traitdata_tmp, 
                                 samples.per.point = samples.per.point,
                                 kde.bandwidth = bd,
                                 verbose = F)
  
  if(get_volume == T){
    return(get_volume(FD_tmp))
  }
  if(get_volume == F){
    return(FD_tmp)
  }
}
FD_from_random <- function(pool, n, traitdata, bd, runs=100, 
                           get_volume = T, samples.per.point = 100, .parallel = F){
  if(runs<1){cat("ERROR: 'run' has to be higher than 1") ; stop()}
  if(n < 3) { return(rep(NA, runs)) } # do not calculate FD for less than 3 species
  else{
    if (length(pool) == 0) { return(rep(NA, runs)) }
    else{
      if(!.parallel){
        replicate(runs, FD_random(pool, 
                                  n, 
                                  traitdata, 
                                  bd, 
                                  get_volume = get_volume, 
                                  samples.per.point = samples.per.point))
      }
      else{
        ncores <- detectCores()
        cl <- makeCluster(ncores)
        
        clusterExport(cl, c("pool","n","bd","get_volume", 
                            "samples.per.point", "FD_random"), envir = .GlobalEnv)
        
        pbreplicate(runs, FD_random(pool, 
                                    n, 
                                    traitdata, 
                                    bd, 
                                    get_volume = get_volume, 
                                    samples.per.point = samples.per.point),
                    cl = cl)
        stopCluster(cl)
      }
    }
  }
}


# calculates hypervolume overlap statistics from two given hypervolumes
hyper_stats <- function(hvol1, hvol2){
  if(is.null(hvol1) | is.null(hvol2) | is.na(hvol1) | is.na(hvol2)){
    return(NA)
  }
  else{
    get_volume(hypervolume_set(hvol1, hvol2, 
                               check.memory = FALSE, 
                               verbose = FALSE)[[3]]) # get the intersect area
    
  }
}

get_quant <- function(quanmean, quant = 10){
  temp <- data.frame(quanmean, quantile=rep(NA, length(quanmean)))
  brks <- with(temp, quantile(temp,na.rm=TRUE, probs = c(seq(0,1,1/quant))))
  r1 <- within(temp, quantile <- cut(quanmean, breaks = brks, labels = 2:length(brks),include.lowest = TRUE))
  return(as.numeric(r1[,2]))
}

```

# Convert Status to extinction probability following Mooers et al. 2008 Plos One
Extinction probabilities for the next 100 years 
LC = 0.0001
NT = 0.01 
VU = 0.1
EN = 0.667 
CR = 0.999
```{r eval = F, results="hide"}

IUCN$prob <- NA
IUCN$prob[which(IUCN$IUCN == "LC")] <- 1 - 0.0001 #(0.9999)
IUCN$prob[which(IUCN$IUCN == "NT")] <- 1 - 0.01 #(0.99)
IUCN$prob[which(IUCN$IUCN == "VU")] <- 1 - 0.1 #(0.9)
IUCN$prob[which(IUCN$IUCN == "EN")] <- 1 - 0.667 #(0.333)
IUCN$prob[which(IUCN$IUCN == "CR")] <- 1 - 0.999 #(0.001)

# Richness maps per threat
plot(rasterFromXYZ(data.frame(XY,rowSums(occr[which(IUCN$prob <= .9)]))))

```

# Predict survivors
```{r eval = F, results="hide"}
current_species <- colnames(occr)
future_species <- replicate(100, # 100 null future comunities based on ...
                            rbinom(current_species, # this list of species
                                   1, # one coint tossed (no need for more because we are replicating above)
                                   IUCN$prob)) # these survivor probabilities 
future_species_ <- data.frame(Species = current_species, 
                              Status = IUCN$IUCN,
                              Prob = IUCN$prob,
                              future_species)

# Check
# View(data.frame(future_species_[,1:3], rowSums(future_species_[,-1:-3])))
# plot(IUCN$prob, rowSums(future_species_[,-1:-3]))
future_species <- future_species_[,-1:-3]
```

# Random future species
Shuffle IUCN probabilities and get the null future species list

```{r eval = F, results="hide"}

random_species <- replicate(100, # 100 null future comunities based on ...
                            rbinom(current_species, # this list of species
                                   1, # one coint tossed (no need for more because we are replicating above)
                                   IUCN$prob[shuffle(length(current_species))])) # shuffle survivor probabilities 

random_species <- data.frame(random_species)
# plot(IUCN$prob, rowSums(random_species))

```


# 1. All amphibians' analysis:
## 1.1. Calculate species richness loss
```{r eval = F, results="hide"}
# SPD total current
SPD_c <- length(current_species) 

# SPD total future
SPD_f <- colSums(future_species)  

# SPD total loss
SPD_loss <- SPD_c - SPD_f 

# % SPD total loss
SPD_loss.p <- (SPD_loss/SPD_c)*100

# Random future
SPD_rf <- colSums(random_species)  

# SPD total random loss
SPD_loss_r <- SPD_c - SPD_rf

# % SPD total random loss
SPD_loss_r.p <- (SPD_loss_r/SPD_c)*100

# Times in which at least one species get extinction in a cell
exteffect <- apply(SPD_closs,1,function(x) length(which(x>0)))
plot(rasterFromXYZ(data.frame(XY,exteffect)))

exteffect <- apply(SPD_closs,1,function(x) length(which(x>=1)))
```

Current total richness: `r SPD_c`  

Future total richness: `r summary(SPD_f)`  
  
Richness loss: `r summary(SPD_loss)`  

Richness loss %: `r summary(SPD_loss.p)`  
   
   
## 1.2. Calculate phylogenetic diversity (PD) loss
```{r eval = F, results="hide"}
# PD total current
PD_c <- sum(tree$edge.length) 

# PD total future
PD_f <- apply(future_species, 2, 
               function(x) 
                 PD_from_list(current_species[which(x==1)], tree)) 

# PD total loss
PD_loss <- PD_c - PD_f

#Test if PD loss is higher or lower than random.
PD_loss_P <- t.test(PD_f, mu =  PD_c) # t.test

# % PD total loss
PD_loss.p <- (PD_loss/PD_c)*100

# PD future random
PD_f_r <- apply(random_species, 2, 
               function(x) 
                 PD_from_list(current_species[which(x==1)], tree)) 

# PD total loss random
PD_loss_random <- PD_c - PD_f_r

# % PD total random loss
PD_loss_r.p <- (PD_loss_random/PD_c)*100

```
  
Current PD: `r PD_c`  

Future PD: `r summary(PD_f)`  
  
PD loss: `r summary(PD_loss)`  

PD loss %: `r summary(PD_loss.p)`  
  
## 1.3. Calculate functional diversity (FD) loss
```{r eval = F, results="hide"}
# We estimated bandwidths using the method of Silverman.
bandwidth_T <- estimate_bandwidth(traits)
bandwidth_cross <- estimate_bandwidth(traits, method = "cross-validation")

# bandwidth experiment
# construct hypervolumes with bandwidth values ranging from 0.01 and 0.5. Check it overlap val

# FD total current
hyperT <- hypervolume_gaussian(name = "current",
                               data = traits, 
                               samples.per.point = 100,
                               kde.bandwidth = bandwidth_T,
                               verbose = F)

FD_c <- get_volume(hyperT)

# FD total future

ncores <- detectCores()
cl <- makeCluster(30)
registerDoParallel(cl)

FD_f <- 
  foreach(i=1:100, .combine = "cbind", .packages=c('hypervolume')) %dopar% { 
    
    vol <- hypervolume_gaussian(name = "future",
                                traits[which(future_species[,i]==1),], 
                                samples.per.point = 100,
                                kde.bandwidth = bandwidth_T,
                                verbose = F)
    
    overla <- hypervolume_set(hyperT, vol, check.memory = F, verbose = F)
    overla2 <- hypervolume_overlap_statistics(overla)
    
    c(get_volume(overla), overla2)
    
  }
# stop the cluster
stopCluster(cl)

FD_f_ <- data.frame(t(FD_f)) 

# FD total loss
# volume loss = current volume - future volume
FD_loss <- FD_c - FD_f_$Intersection.of..current..future.
# % volume loss 
FD_loss.p <- (FD_loss/FD_c)*100

# plot(FD_loss, FD_loss2)

#Test if FD loss is higher or lower than random.
FD_loss_P <- t.test(FD_f_$future, mu =  FD_c) # t.test


# FD future random

ncores <- detectCores()
cl <- makeCluster(30)
registerDoParallel(cl)

FD_f_r <- 
  foreach(i=1:100, .combine = "cbind", .packages=c('hypervolume')) %dopar% { 
    
    vol <- hypervolume_gaussian(name = "future",
                                traits[which(random_species[,i]==1),], 
                                samples.per.point = 100,
                                kde.bandwidth = bandwidth_T,
                                verbose = F)
    
    overla <- hypervolume_set(hyperT, vol, check.memory = F, verbose = F)
    overla2 <- hypervolume_overlap_statistics(overla)
    
    c(get_volume(overla), overla2)
    
  }
# stop the cluster
stopCluster(cl)

FD_f_r_ <- data.frame(t(FD_f_r))

# FD total loss random
# volume loss = current volume - future volume
FD_loss_random <- FD_c - FD_f_r_$Intersection.of..current..future.
# % volume loss 
FD_loss_r.p <- (FD_loss_random/FD_c)*100


```

Current FD: `r FD_c`  

Future FD: `r summary(FD_f_$future)`  
  
FD loss: `r summary(FD_loss)`  
FD loss (fraction of current FD): `r summary(FD_loss2)`  

FD loss %: `r summary(FD_loss.p)`  

## Figure. Observed vs future predicted loss of PD and FD
```{r echo=F}
median.quartile <- function(x){
  out <- quantile(x, probs = c(0.25,0.5,0.75))
  names(out) <- c("ymin","y","ymax")
  return(out) 
}

# SPD future compare dataset
SPD_comp_data <- rbind(data.frame(type = "Predicted", loss = SPD_loss.p),
                       data.frame(type = "Random", loss = SPD_loss_r.p))

SPD_loss_plot <- ggplot(SPD_comp_data, aes(y = loss, x = type, color = type))+
  geom_jitter(alpha = .5)+
  scale_y_continuous(labels = function(x) paste0(x, "%")) +
  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75), trim = F, alpha = .5, width = .5)+
  stat_compare_means(method = "aov", label =  "p.signif") +
  scale_color_manual(values = c("tomato", "cornflowerblue")) +
  theme(legend.position = "none")  +
  ylab("Species loss")+xlab("")

summary(aov(loss~type, SPD_comp_data))

# PD future compare dataset
PD_comp_data <- rbind(data.frame(type = "Predicted", loss = PD_loss.p),
                      data.frame(type = "Random", loss = PD_loss_r.p))

PD_loss_plot <- ggplot(PD_comp_data, aes(y = loss, x = type, color = type))+
  geom_jitter(alpha = .5)+
  scale_y_continuous(labels = function(x) paste0(x, "%")) +
  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75), trim = F, alpha = .5, width = .5)+
  stat_compare_means(method = "aov", label =  "p.signif") +
  scale_color_manual(values = c("tomato", "cornflowerblue")) +
  theme(legend.position = "none")  +
  ylab("Phylogenetic diversity loss")+xlab("")

summary(aov(loss~type, PD_comp_data))

# FD future compare dataset
FD_comp_data <- rbind(data.frame(type = "Predicted", loss = FD_loss.p),
                      data.frame(type = "Random", loss = FD_loss_r.p))

FD_loss_plot <- ggplot(FD_comp_data, aes(y = loss, x = type, color = type))+
  geom_jitter(alpha = .5)+
  scale_y_continuous(labels = function(x) paste0(x, "%")) +
  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75), trim = F, alpha = .5, width = .5)+
  stat_compare_means(method = "aov", label =  "p.signif") +
  scale_color_manual(values = c("tomato", "cornflowerblue")) +
  theme(legend.position = "none")  +
  ylab("Functional diversity loss")+xlab("")

summary(aov(loss~type, FD_comp_data))

# 
pdf("Figs/Fig_1.pdf", width = 7, height = 10/3)
plot_grid(PD_loss_plot, FD_loss_plot, labels = c('(a)', '(b)'), ncol = 2)
dev.off()



```

*** 

\newpage


# 2. Grid cell's analysis
## 2.1. Species richness
```{r eval = F}

NCell <- nrow(occr)


# SPD community current
SPD_cc <- rowSums(occr)

# SPD community future
SPD_cf <- pblapply(1:100, function(x) rowSums(occr[,which(future_species[,x]==1)]))
SPD_cf <- do.call("cbind", SPD_cf)

# SPD community loss
SPD_closs <- apply(SPD_cf, 2, function(x) SPD_cc - x)
SPD_closs_mean <- apply(SPD_closs, 1, function(x) mean(x, na.rm = T))

plot(rasterFromXYZ(data.frame(XY, SPD_closs_mean)))

# % SPD loss
SPD_closs.p <- apply(SPD_closs, 2, function(x) (x/SPD_cc)*100)
SPD_closs.p_mean <- apply(SPD_closs.p, 1, function(x) mean(x, na.rm = T))

plot(rasterFromXYZ(data.frame(XY, SPD_closs.p_mean)))


```


## 2.2. Phylogenetic diversity (PD) loss
```{r eval = F}
###########################

# PD current
PD_cc <- pblapply(1:NCell, function(x) PD_from_list(current_species[which(occr[x,]==1)], tree))
PD_cc <- unlist(PD_cc)  
# takes 4 minutes
# saveRDS(PD_cc, "PD_cc")
# PD_cc <- readRDS("PD_cc")

plot(rasterFromXYZ(data.frame(XY,PD_cc)))

# PD current random
ncores <- detectCores()
cl <- makeCluster(ncores)
clusterExport(cl, c("PD_from_random","PD_random","SPD_cc","current_species", 
                    "occr", "Realm", "drop.tip", "tree"), envir = .GlobalEnv)
PD_cr <- pblapply(1:NCell, function(x) 
  PD_from_random(
    pool = current_species[which(colSums(occr[which(Realm == Realm[x]),])>0)], 
    n = SPD_cc[x], 
    phy = tree,
    runs = 100),
  cl = cl
)
# stop the cluster
stopCluster(cl)
# PD_cr <- do.call("rbind", PD_cr) 
# takes 2 minutes!!!
# saveRDS(PD_cr, "PD_cr")
# PD_cr <- readRDS("PD_cr")

PD_cr_mean <- unlist(apply(PD_cr, 1, function(x) mean(x, na.rm =T)))
PD_cr_sd <- unlist(apply(PD_cr, 1, function(x) sd(x, na.rm =T)))
  
# PD current SES
PD_cc_ses <- (PD_cc - PD_cr_mean)/PD_cr_sd

# plot(rasterFromXYZ(data.frame(XY,PD_cc_ses)))
# plot(PD_cc,PD_cc_ses)

###########################
# PD community future
# set the cluster
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)

# calculate
NCell <- nrow(occr)

start_time <- Sys.time()

PD_cf <- foreach(i=1:100, .combine='cbind', .packages='ape') %dopar% { 
  occu <- occr[,which(future_species[,i]==1)] # occr future i
  unlist(lapply(1:NCell, function(x) 
    PD_from_list(names(occu)[which(occu[x,]==1)], tree)))
}
end_time <- Sys.time()
end_time-start_time
# stop the cluster
stopCluster(cl)
# takes 17min
# saveRDS(PD_cf, "PD_cf")
# PD_cf <- readRDS("PD_cf")

# PD community loss
PD_closs <- apply(PD_cf, 2, function(x) PD_cc - x)

PD_closs_mean <- apply(PD_closs, 1, function(x) mean(x, na.rm =T))
PD_closs_sd <- apply(PD_closs, 1, function(x) sd(x, na.rm = T))

# % PD loss
PD_closs.p <- apply(PD_closs, 2, function(x) (x/PD_cc)*100)
PD_closs.p_mean <- apply(PD_closs.p, 1, function(x) mean(x, na.rm =T))

plot(rasterFromXYZ(data.frame(XY,PD_closs_mean)))
plot(rasterFromXYZ(data.frame(XY,PD_closs.p_mean)))

###########################
# PD future random
# set the cluster
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)

# calculate
NCell <- nrow(occr)

start_time <- Sys.time()

PD_cf_r <- foreach(j=1:NCell, .combine='rbind', .packages=c('ape','permute')) %dopar% { 
  
  sps_i <- which(occr[j,]==1) # species in cell j
  sps_i <- as.character(names(occr[sps_i]))
  
  PD_from_prob(probs = future_species_,
               sps = sps_i,
               phy = tree,
               runs = 100)
}

end_time <- Sys.time()
end_time-start_time
# takes 2.74 minutes
# stop the cluster
stopCluster(cl)
# saveRDS(PD_cf_r, "PD_cf_r")
# PD_cf_r <- readRDS("PD_cf_r")

# extinction intensity is constant between observed and random simulations
plot(apply(PD_closs_r,1,function(x) length(which(na.omit(x)>0))), 
     apply(PD_closs,1,function(x) length(which(na.omit(x)>0))))

PD_closs_r <- apply(PD_cf_r, 2, function(x) PD_cc - x)

# mean/sd of PDloss across 100 random simulated future communities
PD_closs_r_mean <- apply(PD_closs_r, 1, function(x) mean(x, na.rm =T))

# PD_closs_r_mean[which(PD_closs_r_mean==0)] <- .0001
PD_closs_r_sd <- apply(PD_closs_r, 1, function(x) sd(x, na.rm = T))
# PD_closs_r_sd[which(PD_closs_r_sd==0)] <- .0001
# PD_closs_r_sd[is.na(PD_closs_r_sd)] <- 0

PD_closs_r_sdpooled <- sqrt(((PD_closs_sd^2) + (PD_closs_r_sd^2)))
# PD_closs_r_sdpooled[is.na(PD_closs_r_sdpooled)] <- 0
# PD_closs_r_sdpooled[which(PD_closs_r_sdpooled==0)] <- .0001

PD_closs_r_mean[which(SPD_closs_mean==0)] <- NA
PD_closs_r_sd[which(SPD_closs_mean==0)] <- NA
PD_closs_r_sdpooled[which(SPD_closs_mean==0)] <- NA

plot(rasterFromXYZ(data.frame(XY,PD_closs_r_mean)))
plot(rasterFromXYZ(data.frame(XY,PD_closs_r_sd)))
plot(rasterFromXYZ(data.frame(XY,PD_closs_r_sdpooled)))

# PD future SES
PD_closs_ses_ <- (PD_closs_mean - PD_closs_r_mean)/PD_closs_r_sd

plot(rasterFromXYZ(data.frame(XY,PD_closs_ses_)))


PD_closs_ses_[which(is.infinite(PD_closs_ses_))] <- 0

PD_closs_ses_[which(PD_closs_ses_>20)] <- NA
PD_closs_ses_[which(PD_closs_ses_<(-10))] <- NA
plot(rasterFromXYZ(data.frame(XY,PD_closs_ses_)))

PD_closs_ses <- apply(PD_closs, 2,
                      function(x)
                        (x - PD_closs_r_mean)/PD_closs_r_sd)

PD_closs_ses_mean <- apply(PD_closs_ses, 1, function(x) mean(x, na.rm =T))
PD_closs_ses_sd <- apply(PD_closs_ses, 1, function(x) sd(x, na.rm = T))
# PD_closs_ses_sd[is.na(PD_closs_ses_sd)] <- 0

PD_closs_ses_mean[which(SPD_closs_mean==0)] <- NA
PD_closs_ses_sd[which(SPD_closs_mean==0)] <- NA

PD_closs_ses_mean_ <- PD_closs_ses_mean # for plot
PD_closs_ses_mean_[which(PD_closs_ses_mean_>10)] <- 10
PD_closs_ses_mean_[which(PD_closs_ses_mean_<(-10))] <- -10

PD_closs_ses_mean[which(PD_closs_ses_mean>10)] <- NA
PD_closs_ses_mean[which(PD_closs_ses_mean<(-10))] <- NA

plot(rasterFromXYZ(data.frame(XY,PD_closs_ses_mean)))
plot(rasterFromXYZ(data.frame(XY,PD_closs_ses_sd)))

PD_closs_quant <- NA
for(j in 1:NCell){
  tmp <- NA
  for(i in 1:100){
    if(is.na(PD_closs[j,i])){
      tmp[i] <- NA
    }
    else{
      tmp[i] <- (rank(c(PD_closs[j,i], PD_closs_r[j,]))/101)[1]
    }
  }
  PD_closs_quant[j] <- mean(tmp, na.rm = T)
}
PD_closs_quant[which(SPD_closs_mean==0)] <- NA

plot(rasterFromXYZ(data.frame(XY,PD_closs_ses_mean)))
plot(rasterFromXYZ(data.frame(XY,PD_closs_quant)))
plot(rasterFromXYZ(data.frame(XY,PD_closs_quant))<.025)
plot(rasterFromXYZ(data.frame(XY,PD_closs_quant))>.975)

hist(PD_closs_ses_mean)
hist(PD_closs_quant)

```

### Plot
```{r eval = F}
# Plot mean PDloss 
PD_closs_mean <- apply(PD_closs, 1, mean)
plot(rasterFromXYZ(data.frame(XY,PD_closs_mean)))
# Plot mean PDloss SES
plot(rasterFromXYZ(data.frame(XY,PD_closs_ses_mean)))
# Plot sd PDloss SES
plot(rasterFromXYZ(data.frame(XY,PD_closs_ses_sd)))
# Correlation PDloss and PDloss SES
plot(unlist(apply(PD_closs, 1, mean)),PD_closs_ses_mean)
# Correlation SPDloss and PDloss SES
plot(log(unlist(apply(SPD_closs, 1, mean))+1),PD_closs_ses_mean)
# Correlation SPDloss and sd PDloss SES
plot(log(unlist(apply(SPD_closs, 1, mean))+1),PD_closs_ses_sd)


### Compare 
# PDloss future vs random

PD_closs_mean_ <- unlist(lapply(1:NCell, function(x) 
  mean(PD_closs[x, which(SPD_closs[x,] > 0)], na.rm = T)))
PD_closs_r_mean_ <- unlist(lapply(1:NCell, function(x) 
  mean(PD_closs_r_mean[x, which(SPD_closs[x,] > 0)], na.rm = T)))

PD_comp_data <- rbind(data.frame(type = "Predicted-loss", 
                                 PD = PD_closs_mean_),
                      data.frame(type = "Random-loss", 
                                 PD = PD_closs_r_mean_))

ggplot(PD_comp_data, aes(y = PD+1, x = type, color = type))+
  geom_jitter(alpha = .5, width = .3)+
  geom_violin(draw_quantiles = T, trim = F, alpha = .5)+
  stat_compare_means(method = "aov", label =  "p.signif") +
  theme(legend.position = "none")  +
  #scale_y_log10() + 
  ylab("PDloss") + xlab("")

summary(aov(PD~type, PD_comp_data))
mean(na.omit(PD_closs_mean)) # loss
mean(na.omit(PD_closs_r_mean_)) # random


# compare 
# current vs future
PD_cf_mean <- unlist(lapply(1:NCell, function(x) 
  mean(PD_cf[x, which(SPD_closs[x,] > 0)], na.rm = T)))

PD_comp_data <- data.frame(
  rbind(data.frame(type = "Current", PD = PD_cc[which(SPD_closs>0)]),
        data.frame(type = "Future", PD = PD_cf_mean)))

PD_loss_comb_plot <- ggplot(PD_comp_data, aes(y = PD+1, x = type, color = type))+
  geom_jitter(alpha = .5, width = .3)+
  geom_violin(draw_quantiles = c(.25,.5,.75), trim = F, alpha = .5, width = .5)+
  stat_compare_means(method = "aov", label =  "p.signif") +
  theme(legend.position = "none")  +
  #scale_y_log10() + 
  ylab("Phylogenetic diversity (Myr)") + xlab("")

summary(aov(PD~type, PD_comp_data))

```


## 2.3. Functional diversity (FD) loss
```{r eval = F}
# estimated bandwidths for each grid cell using the method of silverman
ncores <- detectCores()
cl <- makeCluster(ncores)
clusterExport(cl, c("FD_from_list","traits","occr","estimate_bandwidth","SPD_cc"), 
              envir = .GlobalEnv)

bandw.exp <- pblapply(1:NCell, function(i)
  
  ifelse(SPD_cc[i] < 3, 
         return(c(Axis1=NA,Axis2=NA,Axis3=NA)), 
         return(estimate_bandwidth(traits[names(occr)[which(occr[i,]==1)],]))),
  cl = cl)

# stop the cluster
stopCluster(cl)
# takes 14 seconds
saveRDS(bandw.exp, "bandw.exp")
# bandw.exp <- readRDS("bandw.exp")

bandw.exp <- do.call("rbind",bandw.exp)
cor(log(Rich),bandw.exp[,1], use = "complete.obs") # bandwidth is not associated with richness.
cor(log(Rich),bandw.exp[,2], use = "complete.obs") # bandwidth is not associated with richness.
cor(log(Rich),bandw.exp[,3], use = "complete.obs") # bandwidth is not associated with richness.
cor(log(Rich),apply(bandw.exp,1,mean), use = "complete.obs") # bandwidth is not associated with richness.

bandw.exp <- apply(bandw.exp, 2, function(x) median(x, na.rm = T))

bandw <- median(bandw.exp)

save.image("PD+FD_erosion_new.RData")

###########################
# FD current

ncores <- detectCores()
cl <- makeCluster(ncores)
clusterExport(cl, 
              c("FD_from_list","traits","occr","bandwidth_T",
                "current_species", "hypervolume_gaussian", "hypervolume", "get_volume"), 
              envir = .GlobalEnv)

FD_cc_ <- pblapply(1:NCell, function(x) 
  FD_from_list(sps = current_species[which(occr[x,]==1)], 
               traitdata = traits, 
               samples.per.point = 100,
               bd = bandwidth_T,
               get_volume = F),
  cl = cl)
# stop the cluster
stopCluster(cl)
# takes 1 minute
# saveRDS(FD_cc_, "FD_cc_")
# FD_cc_ <- readRDS("FD_cc_")
FD_cc <- lapply(FD_cc_, function(x) get_volume(x))
FD_cc[sapply(FD_cc, is.null)] <- NA
FD_cc <- unlist(FD_cc)

# plot(rasterFromXYZ(data.frame(XY,FD_cc)))

# FD current random
ncores <- detectCores()
cl <- makeCluster(ncores)
clusterExport(cl, c("FD_from_random","FD_random","SPD_cc",
                    "current_species","occr", "Realm", "traits",
                    "bandwidth_T", "hypervolume_gaussian", "get_volume"), 
              envir = .GlobalEnv)

FD_cr_ <- pblapply(1:NCell, function(x) 
  FD_from_random(
    pool = current_species[which(colSums(occr[which(Realm == Realm[x]),])>0)], 
    n = SPD_cc[x], 
    traitdata = traits,
    bd = bandwidth_T,
    get_volume = F,
    runs = 100),
  cl = cl
)
# stop the cluster
stopCluster(cl)
# takes 1h13min minutes
# saveRDS(FD_cr_, "FD_cr_")
# FD_cr_ <- readRDS("FD_cr_")

FD_cr <- pblapply(FD_cr_, 
                  function(x) 
                    lapply(x, function(y) get_volume(y)))

FD_cr <- lapply(FD_cr, 
                function(x) 
                  unlist(lapply(x, function(y) ifelse(is.null(y),NA,y))))

FD_cr <- docall("rbind", FD_cr)
  
FD_cr_mean <- unlist(apply(FD_cr, 1, function(x) mean(x, na.rm =T)))
FD_cr_sd <- unlist(apply(FD_cr, 1, function(x) sd(x, na.rm = T)))
  
# FD current SES
FD_cc_ses <- (FD_cc - FD_cr_mean)/FD_cr_sd

# plot(rasterFromXYZ(data.frame(XY,FD_cc_ses)))
# plot(FD_cc,FD_cc_ses)

###########################
# FD community future
# set the cluster
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)

# calculate
NCell <- nrow(occr)

start_time <- Sys.time()

FD_cf_ <- foreach(i=1:100, .packages='hypervolume') %dopar% { 
  occu <- occr[,which(future_species[,i]==1)] # occr future i
  lapply(1:NCell, function(x) 
    FD_from_list(sps = names(occu)[which(occu[x,]==1)], 
                 traitdata = traits, 
                 bd = bandwidth_T,
                 get_volume = F))
}
end_time <- Sys.time()
end_time-start_time
# stop the cluster
stopCluster(cl)
# takes 53min
# saveRDS(FD_cf_, "FD_cf_")
# FD_cf_ <- readRDS("FD_cf_")

FD_cf <- pblapply(FD_cf_, function(x) unlist(lapply(x, function(y) ifelse(is.na(y), NA, get_volume(y)))))
FD_cf <- do.call("cbind", FD_cf)
  
###########################
# FD community loss
ncores <- detectCores()
cl <- makeCluster(5) # have to use this limited number of cores because too memnory been used
registerDoParallel(cl)

start_time <- Sys.time()

FD_closs_ <- 
  foreach(i=1:100, .combine='cbind', .packages=c('hypervolume')) %dopar% { 
    
    lapply(1:NCell, function(x)
      FD_cc[x] - hyper_stats(FD_cc_[[x]], FD_cf_[[i]][[x]])
    )
  }
end_time <- Sys.time()
end_time-start_time
# stop the cluster
stopCluster(cl)
# takes 20min
# saveRDS(FD_closs_, "FD_closs_")
# FD_closs_ <- readRDS("FD_closs_")

FD_closs <- data.frame(apply(FD_closs_,2,as.numeric))

FD_closs_mean <- apply(FD_closs,1,function(x) mean(x, na.rm =T))
FD_closs_sd <- apply(FD_closs,1,function(x) sd(x, na.rm = T))

# % FD loss
FD_closs.p <- apply(FD_closs, 2, function(x) (x/FD_cc)*100)
FD_closs.p_mean <- apply(FD_closs.p,1,function(x) mean(x, na.rm =T))

plot(rasterFromXYZ(data.frame(XY,FD_closs_mean)))
plot(rasterFromXYZ(data.frame(XY,FD_closs.p_mean)))

###########################
# FD loss SES
# set the cluster
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)

# calculate
NCell <- nrow(occr)

start_time <- Sys.time()

FD_closs_r <- foreach(j=1:NCell, .combine='rbind', .packages=c('hypervolume','permute')) %dopar% { 
  
  sps_i <- which(occr[j,]==1) # species in cell j
  sps_i <- as.character(names(occr[sps_i]))
  
  null_FD <- FD_from_prob(probs = future_species_,
                          sps = sps_i,
                          traitdata = traits,
                          bd = bandwidth_T,
                          get_volume = F,
                          runs = 100)
  
  null_FD_loss <- as.numeric(unlist(lapply(1:100, 
                                           function(x) 
                                             hyper_stats(FD_cc_[[j]], null_FD[[x]]))))
  
  # SES FDloss
  return(FD_cc[j] - null_FD_loss)
}

end_time <- Sys.time()
fin_time <- end_time-start_time

# stop the cluster
stopCluster(cl)
# takes 1.14 hours
# saveRDS(FD_closs_r, "FD_closs_r")
# FD_closs_r <- readRDS("FD_closs_r")

# mean/sd of FDloss across 100 random simulated future communities
FD_closs_r_mean <- apply(FD_closs_r, 1, function(x) mean(x, na.rm =T))
FD_closs_r_sd <- apply(FD_closs_r, 1, function(x) sd(x, na.rm = T))
# FD_closs_r_sd[is.na(FD_closs_r_sd)] <- 0

FD_closs_r_sdpooled <- sqrt(((FD_closs_sd^2) + (FD_closs_r_sd^2)))
# FD_closs_r_sdpooled[is.na(FD_closs_r_sd)] <- 0

FD_closs_r_mean[which(SPD_closs_mean==0)] <- NA
FD_closs_r_sd[which(SPD_closs_mean==0)] <- NA
FD_closs_r_sdpooled[which(SPD_closs_mean==0)] <- NA

plot(rasterFromXYZ(data.frame(XY,FD_closs_r_mean)))
plot(rasterFromXYZ(data.frame(XY,FD_closs_r_sd)))
plot(rasterFromXYZ(data.frame(XY,FD_closs_r_sdpooled)))

# FD future SES
FD_closs_ses_ <- (FD_closs_mean - FD_closs_r_mean)/FD_closs_r_sd
plot(rasterFromXYZ(data.frame(XY,FD_closs_ses_)))

plot(PD_closs_ses_,FD_closs_ses_)

FD_closs_ses <- apply(FD_closs, 2,
                      function(x)
                        (x - FD_closs_r_mean)/FD_closs_r_sd)

FD_closs_ses_mean <- apply(FD_closs_ses, 1, function(x) mean(x, na.rm =T))
FD_closs_ses_sd <- apply(FD_closs_ses, 1, function(x) sd(x, na.rm = T))
# FD_closs_ses_sd[is.na(FD_closs_ses_sd)] <- 0

FD_closs_ses_mean[which(SPD_closs_mean==0)] <- NA
FD_closs_ses_sd[which(SPD_closs_mean==0)] <- NA

plot(rasterFromXYZ(data.frame(XY,FD_closs_ses_mean)))
plot(rasterFromXYZ(data.frame(XY,FD_closs_ses_sd)))

hist(FD_closs_ses_mean)

plot(PD_closs_ses_mean,FD_closs_ses_mean)

plot(PD_closs_ses_,FD_closs_ses_)

plot(PD_closs_ses[,1],FD_closs_ses[,1])

plot(SPD_closs_mean,FD_closs_ses_mean)
plot(SPD_closs_mean,PD_closs_ses_mean)

plot(SPD_closs_mean,FD_closs_mean)
plot(SPD_closs_mean,PD_closs_mean)

FD_closs_quant <- NA
for(j in 1:NCell){
  tmp <- NA
  for(i in 1:100){
    if(is.na(FD_closs[j,i])){
      tmp[i] <- NA
    }
    else{
      tmp[i] <- (rank(c(FD_closs[j,i], FD_closs_r[j,]))/101)[1]
    }
  }
  FD_closs_quant[j] <- mean(tmp, na.rm = T)
}
FD_closs_quant[which(SPD_closs_mean==0)] <- NA

plot(rasterFromXYZ(data.frame(XY,FD_closs_ses_mean)))
plot(rasterFromXYZ(data.frame(XY,FD_closs_quant)))
plot(rasterFromXYZ(data.frame(XY,FD_closs_quant))<.025)
plot(rasterFromXYZ(data.frame(XY,FD_closs_quant))>.975)

hist(FD_closs_ses_mean)
hist(FD_closs_quant)


```


### Plot
```{r eval = F}
# Plot mean FDloss 
FD_closs_mean <- apply(FD_closs, 1, mean)
plot(rasterFromXYZ(data.frame(XY,FD_closs_mean)))
# Plot mean FDloss SES
plot(rasterFromXYZ(data.frame(XY,FD_closs_ses_mean))) 
# Plot sd FDloss SES
plot(rasterFromXYZ(data.frame(XY,FD_closs_ses_sd)))
# Correlation FDloss and FDloss SES
plot(unlist(apply(FD_closs, 1, mean)),FD_closs_ses_mean)
# Correlation SPDloss and FDloss SES
plot(log(unlist(apply(SPD_closs, 1, mean))+1),FD_closs_ses_mean)
# Correlation SPDloss and sd FDloss SES
plot(log(unlist(apply(SPD_closs, 1, mean))+1),FD_closs_ses_sd)


### Compare 
# FDloss future vs random

FD_closs_mean_ <- unlist(lapply(1:NCell, function(x) 
  mean(FD_closs[x, which(SPD_closs[x,] > 0)], na.rm = T)))
FD_closs_r_mean_ <- unlist(lapply(1:NCell, function(x) 
  mean(FD_closs_r_mean[x, which(SPD_closs[x,] > 0)], na.rm = T)))

FD_comp_data <- rbind(data.frame(type = "Predicted-loss", 
                                 FD = FD_closs_mean_),
                      data.frame(type = "Random-loss", 
                                 FD = FD_closs_r_mean_))

ggplot(FD_comp_data, aes(y = FD+1, x = type, color = type))+
  geom_jitter(alpha = .5, width = .3)+
  geom_violin(draw_quantiles = T, trim = F, alpha = .5)+
  stat_compare_means(method = "aov", label =  "p.signif") +
  theme(legend.position = "none")  +
  #scale_y_log10() + 
  ylab("FDloss") + xlab("")

summary(aov(FD~type, FD_comp_data))
mean(na.omit(FD_closs_mean)) # loss
mean(na.omit(FD_closs_r_mean_)) # random


# compare 
# current vs future
FD_cf_mean <- unlist(lapply(1:NCell, function(x) 
  mean(FD_cf[x, which(SPD_closs[x,] > 0)], na.rm = T)))

FD_comp_data <- data.frame(
  rbind(data.frame(type = "Current", FD = FD_cc[which(SPD_closs>0)]),
        data.frame(type = "Future", FD = FD_cf_mean)))

FD_loss_comb_plot <- ggplot(FD_comp_data, aes(y = FD+1, x = type, color = type))+
  geom_jitter(alpha = .5, width = .3)+
  geom_violin(draw_quantiles = c(.25,.5,.75), trim = F, alpha = .5, width = .5)+
  stat_compare_means(method = "aov", label =  "p.signif") +
  theme(legend.position = "none")  +
  #scale_y_log10() + 
  ylab(bquote("Functional diversity "~(SD^3))) + xlab("")

summary(aov(FD~type, FD_comp_data))

```

## Figure. Community observed vs future predicted PD and FD
```{r eval = F}
# current vs future
## SPD
SPD_cf_mean <- unlist(lapply(1:NCell, function(x) 
  mean(SPD_cf[x, which(SPD_closs[x,] >=1 )], na.rm = T)))

SPD_comp_data <- data.frame(
  rbind(data.frame(type = "Current", SPD = SPD_cc[which(SPD_closs_mean>=1)]),
        data.frame(type = "Future", SPD = SPD_cf_mean)))

SPD_loss_comb_plot <- ggplot(SPD_comp_data, aes(y = SPD+1, x = type, color = type))+
  geom_jitter(alpha = .3, width = .4)+
  geom_violin(draw_quantiles = c(.25,.5,.75), trim = T, alpha = .5, width = .9)+
  stat_compare_means(method = "aov", label =  "p.signif") +
  theme(legend.position = "none") +
  scale_color_manual(values = c("cornflowerblue", "tomato")) +
  scale_y_log10() + 
  coord_flip()+
  ylab("Species richness") + xlab("") 

summary(aov(SPD~type, SPD_comp_data))

## PD
PD_cf_mean <- unlist(lapply(1:NCell, function(x) 
  mean(PD_cf[x, which(SPD_closs[x,]>=1)], na.rm = T)))

PD_comp_data <- data.frame(
  rbind(data.frame(type = "Current", PD = PD_cc[which(SPD_closs_mean>=1)]),
        data.frame(type = "Future", PD = PD_cf_mean)))

PD_loss_comb_plot <- ggplot(PD_comp_data, aes(y = PD+1, x = type, color = type))+
  geom_jitter(alpha = .3, width = .4)+
  geom_violin(draw_quantiles = c(.25,.5,.75), trim = T, alpha = .5, width = .9)+
  stat_compare_means(method = "aov", label =  "p.signif") +
  theme(legend.position = "none")  +
  scale_color_manual(values = c("cornflowerblue", "tomato")) +
  #scale_y_log10() + 
  ylab("Phylogenetic diversity (Myr)") + xlab("")

summary(aov(PD~type, PD_comp_data))

## FD
FD_cf_mean <- unlist(lapply(1:NCell, function(x) 
  mean(FD_cf[x, which(SPD_closs[x,] >=1)], na.rm = T)))

FD_comp_data <- data.frame(
  rbind(data.frame(type = "Current", FD = FD_cc[which(SPD_closs_mean>=1)]),
        data.frame(type = "Future", FD = FD_cf_mean)))

FD_loss_comb_plot <- ggplot(FD_comp_data, aes(y = FD*100, x = type, color = type))+
  geom_jitter(alpha = .3, width = .4)+
  geom_violin(draw_quantiles = c(.25,.5,.75), trim = T, alpha = .5, width = .9)+
  stat_compare_means(method = "aov", label =  "p.signif") +
  theme(legend.position = "none")  +
  scale_color_manual(values = c("cornflowerblue", "tomato")) +
  #scale_y_log10() + 
  ylab(bquote("Functional diversity "~(SD^3))) + xlab("")

summary(aov(FD~type, FD_comp_data))



pdf("Figs/Fig_2_.pdf", width = 8/3, height = 9)
plot_grid(SPD_loss_comb_plot,
          PD_loss_comb_plot, 
          FD_loss_comb_plot, 
          labels = c('(a)', '(b)', '(c)'), 
          align = 'v',
          nrow = 3)
dev.off()

```



# Create dataset
```{r eval = F, echo = F}

dataset <- data.frame(XY, 
                      SPD_cc, # Current richness 
                      SPD_cf_mean = apply(SPD_cf,1,mean), # Future richness 
                      SPD_closs = apply(SPD_closs,1, function(x) mean(x, na.rm = T)), # Richness loss
                      SPD_closs.p = apply(SPD_closs.p,1,function(x) mean(x, na.rm = T)), # Richness loss %
                      PD_cc, # Current PD 
                      PD_cc_ses, # Current PD ses
                      PD_cf = apply(PD_cf,1,function(x) mean(x, na.rm = T)), # Future PD 
                      PD_closs = PD_closs_mean, # PD loss
                      PD_closs.p = PD_closs.p_mean, # PD loss %
                      PD_closs_ses = PD_closs_ses_mean, # PD loss SES
                      PD_closs_ses_ = PD_closs_ses_, 
                      PD_closs_ses_mean_,# PD loss SES plot
                      PD_closs_quant,
                      FD_cc, # Current FD 
                      FD_cc_ses, # Current FD ses
                      FD_cf = apply(FD_cf,1,function(x) mean(x, na.rm = T)), # Future FD 
                      FD_closs = FD_closs_mean, # FD loss
                      FD_closs.p = FD_closs.p_mean, # FD loss %
                      FD_closs_ses = FD_closs_ses_mean, # FD loss
                      FD_closs_ses_ = FD_closs_ses_, 
                      FD_closs_quant,
                      Realm)

dataset <- dataset[which(dataset$SPD_cc>=3),]
dataset$FD_closs[is.na(dataset$FD_closs)] <- 0
dataset$FD_closs.p[is.na(dataset$FD_closs.p)] <- 0


dataset_ <- dataset[which(dataset$SPD_closs>0),]


```

# Check for normality
```{r eval = F, echo = F}

# PD loss SES
hist(dataset$PD_closs_ses)
qqnorm(dataset$PD_closs_ses)
qqline(dataset$PD_closs_ses)

# FD loss SES
hist(dataset$FD_closs_ses)
qqnorm(dataset$FD_closs_ses)
qqline(dataset$FD_closs_ses)

hist(dataset$FD_closs_ses[-which(dataset$FD_closs_ses > 2.5)])
qqnorm(dataset$FD_closs_ses[-which(dataset$FD_closs_ses > 2.5)])
qqline(dataset$FD_closs_ses[-which(dataset$FD_closs_ses > 2.5)])

# PD loss
hist(log1p(dataset$PD_closs))
qqnorm(log1p(dataset$PD_closs));qqline(log1p(dataset$PD_closs))

# FD loss
hist(log1p(dataset$FD_closs*100))
qqnorm(log1p(dataset$FD_closs*100));qqline(log1p(dataset$FD_closs*100))


par(mfrow = c(2,2))
hist(dataset$PD_closs_ses2, main = "PD loss SES", xlab = "")
hist(dataset$FD_closs_ses2, main = "FD loss SES", xlab = "")

qqnorm(dataset$PD_closs_ses2);qqline(dataset$PD_closs_ses2)
qqnorm(dataset$FD_closs_ses2);qqline(dataset$FD_closs_ses2)

hist(log1p(dataset$FD_closs2*100))
qqnorm(log1p(dataset$FD_closs2*100));qqline(log1p(dataset$FD_closs2*100))


```


# save image
```{r eval = F, echo = F}
save.image("PD+FD_erosion_new.RData")
```

*** 

\newpage

# 4. Test correlations between the loss of multiple dimensions of diversity
Is PD-loss a good predictor of FD-loss?
```{r eval = F}
#Make a matrix of coordinates (X and Y coordinates)
coords<-as.matrix(dataset[,1:2])

#######################
#Define neighbourhood
k1 <- knn2nb(knearneigh(coords))
all.linked <- max(unlist(nbdists(k1, coords)))
nb1.5<-dnearneigh(coords,0,all.linked)
#Spatial weights, illustrated with coding style "W" (row standardized)
nlw<-nb2listw(nb1.5, glist=NULL, style="W", zero.policy=FALSE)


#Make a matrix of coordinates (X and Y coordinates)
coords2<-as.matrix(dataset[which(dataset$SPD_closs>0), 1:2])

#######################
#Define neighbourhood
k1 <- knn2nb(knearneigh(coords2))
all.linked <- max(unlist(nbdists(k1, coords2)))
nb1.5<-dnearneigh(coords2,0,all.linked)
#Spatial weights, illustrated with coding style "W" (row standardized)
nlw2<-nb2listw(nb1.5, glist=NULL, style="W", zero.policy=FALSE)

##############################################
# Spatial models
##############################################

#######################
modelos <- list(as.formula(paste("FD_cc~", "PD_cc",sep = "")), # PD vs FD
                as.formula(paste("FD_cc_ses~", "PD_cc_ses",sep = "")), # PDses vs FDses
                
                as.formula(paste("PD_cc~", "SPD_cc",sep = "")), # richness vs PD
                as.formula(paste("FD_cc~", "SPD_cc",sep = "")), # richness vs FD
                
                as.formula(paste("PD_cc_ses~", "SPD_cc",sep = "")), # richness vs PDses
                as.formula(paste("FD_cc_ses~", "SPD_cc",sep = "")), # richness vs FDses
                
                as.formula(paste("FD_closs~", "PD_closs",sep = "")), # PDloss vs FDloss
                as.formula(paste("FD_closs_ses2~", "PD_closs_ses2",sep = "")), # PDloss.ses vs FDloss.ses
               
                as.formula(paste("PD_cc~", "SPD_closs",sep = "")), # richness.loss vs PDloss
                as.formula(paste("FD_cc~", "SPD_closs",sep = "")), # richness.loss vs FDloss
                
                as.formula(paste("PD_cc_ses2~", "SPD_closs",sep = "")), # richness vs PDloss.ses
                as.formula(paste("FD_cc_ses2~", "SPD_closs",sep = "")) # richness vs FDloss.ses
                )

# set cluster
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)

start_time <- Sys.time()

models <- foreach(i=1:length(modelos), .packages=c('pgirmess','spdep')) %dopar% { 
  
  if(i<=6){
    dataset_use <- dataset
    nlw_use <- nlw
  }
  
  if(i>6){
    dataset_use <- dataset[which(dataset$SPD_closs>0),]
    nlw_use <- nlw2
  }
  
  s_model <- errorsarlm(lm(modelos[[i]], data=dataset_use), listw=nlw_use)
  s_AICc <- AICc(s_model)
  
  l_model <- lm(modelos[[i]], data=dataset_use)
  l_AICc <- AICc(l_model)
  
  s_correl <- pgirmess::correlog(coords=dataset_use[names(residuals(s_model)),1:2], 
                                 z=residuals(s_model), method="Moran")
  s_correl <- data.frame(s_correl)
  
  l_correl <- pgirmess::correlog(coords=dataset_use[names(residuals(l_model)),1:2], 
                                 z=residuals(l_model), method="Moran")
  l_correl <- data.frame(l_correl)
  
  return(list(s_model, l_model,
              s_correl, l_correl))
  
}
# stop the cluster
stopCluster(cl)
end_time <- Sys.time()

time_models <- end_time - start_time



```



# 5. Plots
## PD vs FD (color realm)
```{r}

########################
# PD vs FD
dataplot <- data.frame(PD_cc = dataset$PD_cc,
                       FD_cc = dataset$FD_cc,
                       Realm)

dataplot <- na.omit(dataplot)

# polynomial model
AICc(lm(FD_cc~poly(PD_cc,2),dataplot))
summary(lm(FD_cc~poly(PD_cc,2),dataplot))
# linear model
AICc(lm(FD_cc~PD_cc,dataset))
summary(lm(FD_cc~PD_cc,dataset))
anova(lm(FD_cc~poly(PD_cc,2),dataplot), lm(FD_cc~FD_cc,dataplot))



pdfd <- ggplot(dataset, aes(PD_cc,FD_cc*100))+
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2, alpha = .1) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  geom_smooth(method = "lm", aes(color = Realm), se = T, alpha = .1)+
  geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "black", se = T, alpha = .1)+
  ylim(c(min(FD_cc*100, na.rm = T),max(FD_cc*100, na.rm = T)))+ 
  xlim(c(min(PD_cc, na.rm = T),max(PD_cc, na.rm = T)))+
  labs(x = "Phylogenetic diversity (Myr)", 
       y = bquote("Functional diversity "~(SD^3)))

########################
# PD loss vs FD loss

dataplot <- data.frame(PD_closs = dataset$PD_closs, 
                       FD_closs = dataset$FD_closs, 
                       Realm)

dataplot <- na.omit(dataplot)

# polynomial model
AICc(lm(FD_closs~poly(PD_closs,2),dataplot))
summary(lm(FD_closs~poly(PD_closs,2),dataplot))

# linear model
AICc(lm(FD_closs~PD_closs,dataset))
summary(lm(FD_closs~PD_closs,dataset))

anova(lm(FD_closs~poly(PD_closs,2),dataplot), lm(FD_closs~FD_closs,dataplot))



data_melt <- data.frame("PD"=melt(PD_closs_),
                        "FD"=melt(FD_closs_))

pdfd_loss <- ggplot(dataset[-which(SPD_closs==0),], aes(PD_closs,FD_closs*100))+ 
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2, alpha = .1) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  # geom_smooth(data = data_melt, aes(PD.value,FD.value*100,group=FD.X2), alpha = .05,
  #             method = "lm", formula = y ~ x, color = alpha("red",.05), se = F)+
  geom_smooth(method = "lm", aes(color = Realm), se = T, alpha = .1)+
  geom_smooth(method = "lm", color = "black", se = T, alpha = .1)+
  ylim(c(min(dataplot$FD_closs*100, na.rm = T),max(dataplot$FD_closs*100, na.rm = T)))+ 
  xlim(c(min(dataplot$PD_closs, na.rm = T),max(dataplot$PD_closs, na.rm = T)))+
  labs(x = "Phylogenetic diversity loss (Myr)", 
       y = bquote("Functional diversity loss "~(SD^3)))

########################
# % PD loss vs % FD loss

dataplot <- data.frame(PD_closs = log(dataset$PD_closs.p+1), 
                       FD_closs = log(dataset$FD_closs.p+1),
                       Realm)

dataplot <- na.omit(dataplot)

# polynomial model
AICc(lm(FD_closs~poly(PD_closs,3),dataplot))
summary(lm(FD_closs~poly(PD_closs,3),dataplot))

# linear model
AICc(lm(FD_closs~PD_closs,dataplot))
summary(lm(FD_closs~PD_closs,dataplot))

anova(lm(FD_closs~poly(PD_closs,2),dataplot), lm(FD_closs~FD_closs,dataplot))



data_melt <- data.frame("PD"=melt(PD_closs.p),
                        "FD"=melt(FD_closs.p))

pdfd_loss.p <- ggplot(dataset, aes(PD_closs.p,FD_closs.p))+ 
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  # scale_x_log10()+scale_y_log10()+
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  # geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "red", se = T)+
  geom_smooth(data = data_melt, aes(PD.value,FD.value,group=FD.X2), alpha = .05,
              method = "lm", formula = y ~ x, color = alpha("red",.05), se = F)+
  # geom_smooth(method = "lm", color = "red", se = T)+
  ylim(c(min(FD_closs.p, na.rm = T),max(FD_closs.p, na.rm = T)))+
  xlim(c(min(PD_closs.p, na.rm = T),max(PD_closs.p, na.rm = T)))+
  labs(x = "% Phylogenetic diversity loss (Myr)", 
       y = bquote("% Functional diversity loss "~(SD^3)))

########################
# PDses vs FDses

dataplot <- na.omit(data.frame(PD_cc_ses=dataset$PD_cc_ses,
                               FD_cc_ses=dataset$FD_cc_ses,
                               Realm))

# polynomial model
AICc(lm(FD_cc_ses~poly(PD_cc_ses,2),dataplot))
summary(lm(FD_cc_ses~poly(PD_cc_ses,2),dataplot))
# linear model
AICc(lm(FD_cc_ses~PD_cc_ses,dataset))
summary(lm(FD_cc_ses~PD_cc_ses,dataset))
anova(lm(FD_cc_ses~poly(PD_cc_ses,2),dataplot), lm(FD_cc_ses~PD_cc_ses,dataplot))


pdfd_ses<-ggplot(dataset, aes(PD_cc_ses,FD_cc_ses))+
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2, alpha = .1) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  # scale_y_continuous(labels=scaleFUN) +
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  geom_smooth(method = "lm", aes(color = Realm), se = T, alpha = .1)+
  geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "black", se = T, alpha = .1)+
  ylim(c(min(FD_cc_ses, na.rm = T),max(FD_cc_ses, na.rm = T)))+ 
  xlim(c(min(PD_cc_ses, na.rm = T),max(PD_cc_ses, na.rm = T)))+
  labs(x = "Phylogenetic diversity (SES)", 
       y = "Functional diversity (SES)")

########################
# PDses loss vs FDses loss

dataplot <- data.frame(PD_closs = dataset$PD_closs_ses,
                       FD_closs = dataset$FD_closs_ses,
                       Realm)
dataplot <- na.omit(dataplot)

# polynomial model
AICc(lm(FD_closs~poly(PD_closs,2),dataplot))
summary(lm(FD_closs~poly(PD_closs,2),dataplot))

# linear model
AICc(lm(FD_closs~PD_closs,dataplot))
summary(lm(FD_closs~PD_closs,dataset))

anova(lm(FD_closs~poly(PD_closs,2),dataplot), lm(FD_closs~FD_closs,dataplot))


data_melt <- data.frame("PD"=melt(PD_closs_ses),
                        "FD"=melt(FD_closs_ses_))

pdfd_ses_loss <- ggplot(na.omit(dataplot), 
                        aes(PD_closs,FD_closs))+ 
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2, alpha=.1) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  # geom_smooth(data = data_melt, aes(PD.value,FD.value,group=FD.variable), alpha = .05,
  #             method = "lm", formula = y ~ x, color = alpha("red",.05), se = F)+
  geom_smooth(method = "lm", aes(color = Realm), se = T, alpha = .1)+
  geom_smooth(method = "lm", color = "black", se = T, alpha = .1)+
  ylim(c(min(dataplot$FD_closs, na.rm = T), max(dataplot$FD_closs, na.rm = T)))+
  xlim(c(min(dataplot$PD_closs, na.rm = T), max(dataplot$PD_closs, na.rm = T)))+
  labs(x = "Phylogenetic diversity loss (SES)", 
       y = "Functional diversity loss (SES)")


pdf(paste("Figs/Fig2_PDxFD_color.pdf",sep=""),width=9*2,height=9*2,useDingbats=F)
plot_grid(pdfd, pdfd_loss,
          pdfd_ses, pdfd_ses_loss,
          labels = c('(a)', '(b)', 
                     '(c)', '(d)'), 
          align = 'v',
          nrow = 2)
dev.off()

```

## PD vs FD
```{r}

########################
# PD vs FD
dataplot <- data.frame(PD_cc = dataset_$PD_cc,
                       FD_cc = dataset_$FD_cc,
                       Realm = dataset_$Realm)

dataplot <- na.omit(dataplot)

# polynomial model
AICc(lm(FD_cc~poly(PD_cc,2),dataplot))
summary(lm(FD_cc~poly(PD_cc,2),dataplot))
# linear model
AICc(lm(FD_cc~PD_cc,dataset))
summary(lm(FD_cc~PD_cc,dataset))
anova(lm(FD_cc~poly(PD_cc,2),dataplot), lm(FD_cc~FD_cc,dataplot))



pdfd <- ggplot(dataplot, aes(PD_cc,FD_cc*100))+
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  # geom_smooth(method = "lm", aes(color = Realm), se = T, alpha = .1)+
  geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "red", se = T)+
  ylim(c(min(FD_cc*100, na.rm = T),max(FD_cc*100, na.rm = T)))+ 
  xlim(c(min(PD_cc, na.rm = T),max(PD_cc, na.rm = T)))+
  labs(x = "Phylogenetic diversity (Myr)", 
       y = bquote("Functional diversity "~(SD^3)))

########################
# PD loss vs FD loss

dataplot <- data.frame(PD_closs = dataset_$PD_closs, 
                       FD_closs = dataset_$FD_closs, 
                       Realm = dataset_$Realm)
dataplot <- na.omit(dataplot)

# polynomial model
AICc(lm(FD_closs~poly(PD_closs,2),dataplot))
summary(lm(FD_closs~poly(PD_closs,2),dataplot))

# linear model
AICc(lm(FD_closs~PD_closs,dataset))
summary(lm(FD_closs~PD_closs,dataset))

anova(lm(FD_closs~poly(PD_closs,2),dataplot), lm(FD_closs~FD_closs,dataplot))

data_melt <- data.frame("PD"=melt(PD_closs_),
                        "FD"=melt(FD_closs_))

pdfd_loss <- ggplot(dataplot, aes(PD_closs,FD_closs*100))+ 
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  geom_smooth(data = data_melt, aes(PD.value,FD.value*100,group=FD.X2), alpha = .05,
              method = "lm", formula = y ~ x, color = alpha("red",.05), se = F)+
  # geom_smooth(method = "lm", aes(color = Realm), se = T, alpha = .1)+
  # geom_smooth(method = "lm", color = "red", se = T, alpha = .1)+
  ylim(c(min(dataplot$FD_closs*100, na.rm = T),max(dataplot$FD_closs*100, na.rm = T)))+ 
  xlim(c(min(dataplot$PD_closs, na.rm = T),max(dataplot$PD_closs, na.rm = T)))+
  labs(x = "Phylogenetic diversity loss (Myr)", 
       y = bquote("Functional diversity loss "~(SD^3)))

########################
# % PD loss vs % FD loss

dataplot <- data.frame(PD_closs = dataset_$PD_closs.p, 
                       FD_closs = dataset_$FD_closs.p,
                       Realm = dataset_$Realm)
dataplot <- na.omit(dataplot)

# polynomial model
AICc(lm(FD_closs~poly(PD_closs,3),dataplot))
summary(lm(FD_closs~poly(PD_closs,3),dataplot))

# linear model
AICc(lm(FD_closs~PD_closs,dataplot))
summary(lm(FD_closs~PD_closs,dataplot))

anova(lm(FD_closs~poly(PD_closs,2),dataplot), lm(FD_closs~FD_closs,dataplot))



data_melt <- data.frame("PD"=melt(PD_closs.p),
                        "FD"=melt(FD_closs.p))

pdfd_loss.p <- ggplot(dataplot, aes(PD_closs,FD_closs))+ 
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  # scale_x_log10()+scale_y_log10()+
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  # geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "red", se = T)+
  # geom_smooth(data = data_melt, aes(PD.value,FD.value,group=FD.X2), alpha = .05,
  #             method = "lm", formula = y ~ x, color = alpha("red",.05), se = F)+
  # geom_smooth(method = "lm", color = "red", se = T)+
  ylim(c(0,60))+
  xlim(c(0,60))+
  labs(x = "% Phylogenetic diversity loss (Myr)", 
       y = bquote("% Functional diversity loss "~(SD^3)))

########################
# PDses vs FDses

dataplot <- na.omit(data.frame(PD_cc_ses=dataset_$PD_cc_ses,
                               FD_cc_ses=dataset_$FD_cc_ses,
                               Realm = dataset_$Realm))

# polynomial model
AICc(lm(FD_cc_ses~poly(PD_cc_ses,2),dataplot))
summary(lm(FD_cc_ses~poly(PD_cc_ses,2),dataplot))
# linear model
AICc(lm(FD_cc_ses~PD_cc_ses,dataset))
summary(lm(FD_cc_ses~PD_cc_ses,dataset))
anova(lm(FD_cc_ses~poly(PD_cc_ses,2),dataplot), lm(FD_cc_ses~PD_cc_ses,dataplot))


pdfd_ses<-ggplot(dataset, aes(PD_cc_ses,FD_cc_ses))+
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  # scale_y_continuous(labels=scaleFUN) +
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  # geom_smooth(method = "lm", aes(color = Realm), se = T, alpha = .1)+
  geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "red", se = T)+
  ylim(c(min(FD_cc_ses, na.rm = T),max(FD_cc_ses, na.rm = T)))+ 
  xlim(c(min(PD_cc_ses, na.rm = T),max(PD_cc_ses, na.rm = T)))+
  labs(x = "Phylogenetic diversity (SES)", 
       y = "Functional diversity (SES)")

########################
# PDses loss vs FDses loss

dataplot <- data.frame(PD_closs = dataset_$PD_closs_ses,
                       FD_closs = dataset_$FD_closs_ses,
                       Realm = dataset_$Realm)
dataplot <- na.omit(dataplot)

# polynomial model
AICc(lm(FD_closs~poly(PD_closs,2),dataplot))
summary(lm(FD_closs~poly(PD_closs,2),dataplot))

# linear model
AICc(lm(FD_closs~PD_closs,dataplot))
summary(lm(FD_closs~PD_closs,dataset))

anova(lm(FD_closs~poly(PD_closs,2),dataplot), lm(FD_closs~FD_closs,dataplot))

data_melt <- data.frame("PD"=melt(PD_closs_ses),
                        "FD"=melt(FD_closs_ses_))

pdfd_ses_loss <- ggplot(dataplot, 
                        aes(PD_closs,FD_closs))+ 
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  geom_smooth(data = data_melt, aes(PD.value,value,group=PD.X2), alpha = .05,
              method = "lm", formula = y ~ x, color = alpha("red",.05), se = F)+
  # geom_smooth(method = "lm", aes(color = Realm), se = T, alpha = .1)+
  # geom_smooth(method = "lm", color = "black", se = T, alpha = .1)+
  ylim(c(min(dataplot$FD_closs, na.rm = T), max(dataplot$FD_closs, na.rm = T)))+
  xlim(c(min(dataplot$PD_closs, na.rm = T), max(dataplot$PD_closs, na.rm = T)))+
  scale_y_continuous(breaks = c(-9,-4.5,0,4.5,9,13.5)) +
  # geom_hline(yintercept=0)+geom_vline(xintercept=0)+
  labs(x = "Phylogenetic diversity loss (SES)", 
       y = "Functional diversity loss (SES)")


pdf(paste("Figs/Fig2_PDxFD.pdf",sep=""),width=9*2,height=9*2,useDingbats=F)
plot_grid(pdfd, pdfd_loss, 
          pdfd_ses, pdfd_ses_loss,
          labels = c('(a)', '(b)', 
                     '(c)', '(d)'), 
          align = 'v',
          nrow = 2)
dev.off()

```

## SR vs PD/FD loss
```{r}



########################

sr_srp <- ggplot(na.omit(dataset_), aes(SPD_cc,SPD_closs.p))+
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  # geom_smooth(method = "lm", aes(color = Realm), se = T, alpha = .1)+
  # geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "red", se = T)+
  labs(x = "Species richness (extant)", 
       y = "Species richness loss (%)")

sr_pd <- ggplot(na.omit(dataset_), aes(SPD_cc,PD_closs))+
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  # geom_smooth(method = "lm", aes(color = Realm), se = T, alpha = .1)+
  # geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "red", se = T)+
  labs(x = "Species richness (extant)", 
       y = "Phylogenetic diversity loss (Myr)")

sr_pd.p <- ggplot(na.omit(dataset_), aes(SPD_cc,PD_closs.p))+
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  # geom_smooth(method = "lm", aes(color = Realm), se = T, alpha = .1)+
  # geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "red", se = T)+
  labs(x = "Species richness (extant)", 
       y = "Phylogenetic diversity loss (%)")

sr_pd.ses <- ggplot(na.omit(dataset_), aes(SPD_cc,PD_closs_ses))+
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  # geom_smooth(method = "lm", aes(color = Realm), se = T, alpha = .1)+
  # geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "red", se = T)+
  labs(x = "Species richness (extant)", 
       y = "Phylogenetic diversity loss (SES)")

sr_fd <- ggplot(na.omit(dataset_), aes(SPD_cc,FD_closs))+
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  # geom_smooth(method = "lm", aes(color = Realm), se = T, alpha = .1)+
  # geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "red", se = T)+
  labs(x = "Species richness (extant)", 
       y = bquote("Functional diversity loss "~(SD^3)))

sr_fd.p <- ggplot(na.omit(dataset_), aes(SPD_cc,FD_closs.p))+
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  # geom_smooth(method = "lm", aes(color = Realm), se = T, alpha = .1)+
  # geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "red", se = T)+
  labs(x = "Species richness (extant)", 
       y = "Functional diversity loss (%)")

sr_fd.ses <- ggplot(na.omit(dataset_), aes(SPD_cc,FD_closs_ses))+
  geom_point(aes(colour=factor(Realm), fill = factor(Realm), shape = factor(Realm)),
             size=2) + 
  scale_colour_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC","gray"))+
  scale_fill_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))+
  scale_shape_manual(values=c(21,22,21,22,21,22,21,22,21,22,21,22))+
  theme_classic()+
  theme(text = element_text(colour="black", size = 26),legend.title = element_blank(),  aspect.ratio=1) +
  guides(colour = guide_legend(override.aes = list(size=4))) +
  # geom_smooth(method = "lm", aes(color = Realm), se = T, alpha = .1)+
  # geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "red", se = T)+
  labs(x = "Species richness (extant)", 
       y = "Functional diversity loss (SES)")

pdf(paste("Figs/FigSupp_SRxPDxFD_loss.pdf",sep=""),width=9*3,height=9*3,useDingbats=F)
plot_grid(sr_srp, 
          sr_pd,sr_pd.p,sr_pd.ses,
          sr_fd,sr_fd.p,sr_fd.ses,
          labels = c('(a)', 
                     '(b)', '(c)', '(d)', 
                     '(b)', '(c)', '(d)'), 
          align = 'v',
          nrow = 3)
dev.off()

```





  
*** 

\newpage

##Figure. Actual vs future diversity pattern.    
```{r echo=F, results="hide"}
# X11(width = 10, height = 5)
pdf("Figs/Fig2_CurrentvsLoss.pdf", width = 10, height = 5)

layout(matrix(c(1:6), ncol = 2, byrow = T))
par(mar=c(1,0,1.2,1))

rampa <- colorRampPalette(c('cornflowerblue','yellow','red'))(10)

# Get class intervals SPD
SR_classint <- BAMMtools::getJenksBreaks(dataset_$SPD_closs, 10)
# avoid identical breaks
SR_classint <- unique(SR_classint)
# Get class intervals PD
PD_classint <- BAMMtools::getJenksBreaks(round(dataset_$PD_closs,0), 10)
# avoid identical breaks
PD_classint <- unique(PD_classint)
PD_classint[1] <- min(round(dataset_$PD_closs,0),na.rm = T)
PD_classint[10] <- max(round(dataset_$PD_closs,0),na.rm = T)
# Get class intervals FD
FD_classint <- BAMMtools::getJenksBreaks(dataset_$FD_closs*100, 10)
# avoid identical breaks
FD_classint <- unique(FD_classint)
FD_classint[1] <- min(dataset_$FD_closs*100,na.rm = T)
FD_classint[10] <- max(dataset_$FD_closs*100,na.rm = T)
FD_classint <- round(FD_classint,3)

# richness
SR <- cbind(data.frame(dataset_[,1:2]),Var=dataset_$SPD_closs)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR,main='Species richness loss',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR,add=T,main='Species richness',axes=F,box=F,
     axis.args=list(at=round(func_splint(c(1:78),5),0),
                    labels=round(func_splint(c(1:78),5),0)), 
     breaks = SR_classint, col=rampa)
plot(mundi, axes = F, add=T)

# richness-loss
SR <- cbind(data.frame(dataset_[,1:2]),Var=dataset_$SPD_closs.p)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR,main='Species richness loss (%)',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR,add=T,axes=F,box=F,
     axis.args=list(at=c(0,25,50,75,100), labels=c(0,25,50,75,100)), 
     breaks = c(0,1,2.5,5,10,20,25,50,75,100), col=rampa)
plot(mundi, axes = F, add=T)

# PD
SR <- cbind(data.frame(dataset_[,1:2]),Var=round(dataset_$PD_closs,0))
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR,main='Phylogenetic diversity loss (Myr)',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR,add=T,axes=F,box=F, 
     axis.args=list(at=c(1,round(func_splint(dataset_$PD_closs,5),0)[-1]),
                    labels=c(1,round(func_splint(dataset_$PD_closs,5),0)[-1])), 
     breaks = PD_classint, col=rampa)
plot(mundi, axes = F, add=T)

# PD-loss
SR <- cbind(data.frame(dataset_[,1:2]),Var=dataset_$PD_closs.p)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR,main='Phylogenetic diversity loss (%)',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR,add=T,axes=F,box=F,
     axis.args=list(at=c(0,25,50,75,100), labels=c(0,25,50,75,100)), 
     breaks = c(0,1,2.5,5,10,20,25,50,75,100), col=rampa)
plot(mundi, axes = F, add=T)

# FD
SR <- cbind(data.frame(dataset_[,1:2]),Var=round(dataset_$FD_closs*100,2))
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR,main=bquote(bold("Functional diversity loss"~(SD^3))),axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR,add=T,axes=F,box=F, 
     axis.args=list(at=(round(func_splint(dataset_$FD_closs*100,5),2)),
                    labels=round(func_splint(dataset_$FD_closs*100,5),2)), 
     breaks = FD_classint, col=rampa)
plot(mundi, axes = F, add=T)

# FD-loss
SR <- cbind(data.frame(dataset_[,1:2]),Var=dataset_$FD_closs.p)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR,main='Functional diversity loss (%)',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR,add=T,axes=F,box=F,
     axis.args=list(at=c(0,25,50,75,100), labels=c(0,25,50,75,100)), 
     breaks = c(0,1,2.5,5,10,20,25,50,75,100), col=rampa)
plot(mundi, axes = F, add=T)


dev.off()
```

## Figure. Actual vs future diversity pattern. 2    
```{r echo=F, results="hide"}
# X11(width = 10, height = 5)
pdf("Figs/Fig2_CurrentvsLoss_2.pdf", width = 5, height = 6.666)

layout(matrix(c(1:4), ncol = 1, byrow = T))
par(mar=c(1,0,1.2,1))

rampa <- colorRampPalette(c('cornflowerblue','yellow','red'))(10)

# Get class intervals SPD
SR_classint <- BAMMtools::getJenksBreaks(dataset_$SPD_closs, 10)
# avoid identical breaks
SR_classint <- unique(SR_classint)
# Get class intervals PD
PD_classint <- BAMMtools::getJenksBreaks(round(dataset_$PD_closs,0), 10)
# avoid identical breaks
PD_classint <- unique(PD_classint)
PD_classint[1] <- min(round(dataset_$PD_closs,0),na.rm = T)
PD_classint[10] <- max(round(dataset_$PD_closs,0),na.rm = T)
# Get class intervals FD
FD_classint <- BAMMtools::getJenksBreaks(dataset_$FD_closs*100, 10)
# avoid identical breaks
FD_classint <- unique(FD_classint)
FD_classint[1] <- min(dataset_$FD_closs*100,na.rm = T)
FD_classint[10] <- max(dataset_$FD_closs*100,na.rm = T)
FD_classint <- round(FD_classint,3)

# richness
SR <- cbind(data.frame(dataset_[,1:2]),Var=dataset_$SPD_closs)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR,main='Species richness loss',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR,add=T,main='Species richness',axes=F,box=F,
     axis.args=list(at=round(func_splint(c(1:78),5),0),
                    labels=round(func_splint(c(1:78),5),0)), 
     breaks = SR_classint, col=rampa)
plot(mundi, axes = F, add=T)


# PD
SR <- cbind(data.frame(dataset_[,1:2]),Var=round(dataset_$PD_closs,0))
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR,main='Phylogenetic diversity loss (Myr)',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR,add=T,axes=F,box=F, 
     axis.args=list(at=c(1,round(func_splint(dataset_$PD_closs,5),0)[-1]),
                    labels=c(1,round(func_splint(dataset_$PD_closs,5),0)[-1])), 
     breaks = PD_classint, col=rampa)
plot(mundi, axes = F, add=T)


# FD
SR <- cbind(data.frame(dataset_[,1:2]),Var=round(dataset_$FD_closs*100,2))
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR,main=bquote(bold("Functional diversity loss"~(SD^3))),axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR,add=T,axes=F,box=F, 
     axis.args=list(at=(round(func_splint(dataset_$FD_closs*100,5),2)),
                    labels=round(func_splint(dataset_$FD_closs*100,5),2)), 
     breaks = FD_classint, col=rampa)
plot(mundi, axes = F, add=T)

# RGB
plot(SR,main="",axes=F,box=F, col='white',legend=F)
plotRGB(SR_PD_FD, stretch='lin', add=T)
plot(mundi, axes = F, add=T)

dev.off()
```

##Figure. Loss SES difference
```{r echo=F, results="hide"}

# Get class intervals PD SES
max_abolute_PD <- max(abs(c(na.omit(dataset_$PD_closs_ses_mean_))))
brk1 <- round(func_splint(c(0,min(na.omit(dataset_$PD_closs_ses_mean_))),3),2)
brk2 <- round(func_splint(c(0,max(na.omit(dataset_$PD_closs_ses_mean_))),3),2)
PD_brk <- unique(sort(c(brk1,brk2)))

brk12 <- round(func_splint(c(-.5,min(na.omit(dataset_$PD_closs_ses_mean_))),6),2)
brk22 <- round(func_splint(c(.5,max(na.omit(dataset_$PD_closs_ses_mean_))),6),2)
PD_brk2 <- unique(sort(c(brk12,brk22)))

# Get class intervals FD SES
max_abolute_FD <- max(abs(c(na.omit(dataset_$FD_closs_ses[-which(dataset_$FD_closs_ses<(-10))]))))
brk1 <- round(func_splint(c(0,min(na.omit(dataset_$FD_closs_ses[-which(dataset_$FD_closs_ses<(-10))]))),3),2)
brk2 <- round(func_splint(c(0,max(na.omit(dataset_$FD_closs_ses[-which(dataset_$FD_closs_ses<(-10))]))),3),2)
FD_brk <- unique(sort(c(brk1,brk2)))

brk12 <- round(func_splint(c(-3,min(na.omit(dataset_$FD_closs_ses[-which(dataset_$FD_closs_ses<(-10))]))),6),2)
brk22 <- round(func_splint(c(3,max(na.omit(dataset_$FD_closs_ses[-which(dataset_$FD_closs_ses<(-10))]))),6),2)
FD_brk2 <- unique(sort(c(brk12,brk22)))

# Get class intervals difference
######## also test with quantiles
diff <- dataset_$FD_closs_ses - dataset_$PD_closs_ses_

max_abolute_Diff <- max(abs(na.omit(diff)))
brk1 <- round(func_splint(c(0,min(na.omit(diff))),3),2)
brk2 <- round(func_splint(c(0,max(na.omit(diff))),3),2)
Diff_brk <- unique(sort(c(brk1,brk2)))

brk12 <- round(func_splint(c(-3,min(na.omit(diff))),6),2)
brk22 <- round(func_splint(c(3,max(na.omit(diff))),6),2)
Diff_brk2 <- unique(sort(c(brk12,brk22)))

# X11(width = 10, height = 5)
pdf("Figs/Fig2_Loss_SES_difference.pdf", width = 5, height = 5)

layout(matrix(c(1:3), ncol = 1, byrow = T))
par(mar=c(1,0,1.2,1))


# PD-loss SES
SR <- cbind(dataset_[,1:2],Var=dataset_$PD_closs_ses_mean_)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR, main='Phylogenetic diversity loss (SES)',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR,add=T,axes=F,box=F, 
     axis.args=list(at=PD_brk,
                    labels=PD_brk),
     breaks=PD_brk2,
     col=colorRampPalette(c('darkblue','white','red'))(11))
plot(mundi, axes = F, add=T)

# FD-loss SES
SR <- cbind(dataset_[-which(dataset_$FD_closs_ses<(-10)),1:2],
            Var=dataset_$FD_closs_ses[-which(dataset_$FD_closs_ses<(-10))])
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR, main='Functional diversity loss (SES)',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR,add=T,axes=F,box=F, 
     axis.args=list(at=FD_brk,
                    labels=FD_brk),
     breaks=FD_brk2,
     col=colorRampPalette(c('darkblue','white','red'))(11))
plot(mundi, axes = F, add=T)

# Difference

SR <- cbind(dataset_[,1:2],Var=diff)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR, main='PD vs FD',axes=F,box=F, col='white',legend=F)
plot(land, col="gray",border="gray",add = T)
plot(SR,add=T,axes=F,box=F, 
     axis.args=list(at=Diff_brk,
                    labels=Diff_brk), 
     breaks=Diff_brk2,
     col=colorRampPalette(c('darkblue','white','red'))(11))
plot(mundi, axes = F, add=T)

dev.off()

##################

test <- data.frame(x = density(na.omit(dataset_$PD_closs_ses_mean_))$x, 
                   y = density(na.omit(dataset_$PD_closs_ses_mean_))$y)

density_PD <- ggplot(data.frame(x = test$x, y = test$y), aes(x, y)) + geom_line() + 
  geom_segment(aes(xend = x, yend = 0, colour = x)) + 
  theme_bw()+
  scale_colour_gradient2(low="darkblue",mid="white",high="red")


test <- data.frame(x = density(na.omit(dataset_$FD_closs_ses[-which(dataset_$FD_closs_ses<(-10))]))$x, 
                   y = density(na.omit(dataset_$FD_closs_ses[-which(dataset_$FD_closs_ses<(-10))]))$y)

density_FD <- ggplot(data.frame(x = test$x, y = test$y), aes(x, y)) + geom_line() + 
  geom_segment(aes(xend = x, yend = 0, colour = x)) + 
  theme_bw()+
  scale_colour_gradient2(low="darkblue",mid="white",high="red")

test <- data.frame(x = density(na.omit(diff))$x, 
                   y = density(na.omit(diff))$y)

density_PDFD <- ggplot(data.frame(x = test$x, y = test$y), aes(x, y)) + geom_line() + 
  geom_segment(aes(xend = x, yend = 0, colour = x)) + 
  theme_bw()+
  scale_colour_gradient2(low="darkblue",mid="white",high="red")

pdf("Figs/Fig2_Loss_SES_hist.pdf", width = 5, height = 3.333333)

plot_grid(density_PD, density_FD, 
          align = 'v',
          nrow = 2)
dev.off()


```

##Figure. Loss SES bivariate
```{r echo=F, results="hide"}

# Get class intervals PD SES
max_abolute_PD <- max(abs(c(na.omit(dataset_$PD_closs_ses_mean_))))
brk1 <- round(func_splint(c(0,min(na.omit(dataset_$PD_closs_ses_mean_))),3),2)
brk2 <- round(func_splint(c(0,max(na.omit(dataset_$PD_closs_ses_mean_))),3),2)
PD_brk <- unique(sort(c(brk1,brk2)))

brk12 <- round(func_splint(c(-.5,min(na.omit(dataset_$PD_closs_ses_mean_))),6),2)
brk22 <- round(func_splint(c(.5,max(na.omit(dataset_$PD_closs_ses_mean_))),6),2)
PD_brk2 <- unique(sort(c(brk12,brk22)))

# Get class intervals FD SES
max_abolute_FD <- max(abs(c(na.omit(dataset_$FD_closs_ses[-which(dataset_$FD_closs_ses<(-10))]))))
brk1 <- round(func_splint(c(0,min(na.omit(dataset_$FD_closs_ses[-which(dataset_$FD_closs_ses<(-10))]))),3),2)
brk2 <- round(func_splint(c(0,max(na.omit(dataset_$FD_closs_ses[-which(dataset_$FD_closs_ses<(-10))]))),3),2)
FD_brk <- unique(sort(c(brk1,brk2)))

brk12 <- round(func_splint(c(-3,min(na.omit(dataset_$FD_closs_ses[-which(dataset_$FD_closs_ses<(-10))]))),6),2)
brk22 <- round(func_splint(c(3,max(na.omit(dataset_$FD_closs_ses[-which(dataset_$FD_closs_ses<(-10))]))),6),2)
FD_brk2 <- unique(sort(c(brk12,brk22)))

# Get class intervals difference
######## also test with quantiles
diff <- dataset_$FD_closs_ses - dataset_$PD_closs_ses_

max_abolute_Diff <- max(abs(na.omit(diff)))
brk1 <- round(func_splint(c(0,min(na.omit(diff))),3),2)
brk2 <- round(func_splint(c(0,max(na.omit(diff))),3),2)
Diff_brk <- unique(sort(c(brk1,brk2)))

brk12 <- round(func_splint(c(-3,min(na.omit(diff))),6),2)
brk22 <- round(func_splint(c(3,max(na.omit(diff))),6),2)
Diff_brk2 <- unique(sort(c(brk12,brk22)))

# X11(width = 10, height = 5)
pdf("Figs/Fig2_Loss_SES_bivariate.pdf", width = 5, height = 5)

layout(matrix(c(1:3), ncol = 1, byrow = T))
par(mar=c(1,0,1.2,1))


# PD-loss SES
SR <- cbind(dataset_[,1:2],Var=dataset_$PD_closs_ses_mean_)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
PD_raster <- raster(SR)
plot(PD_raster, main='Phylogenetic diversity loss (SES)',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(PD_raster,add=T,axes=F,box=F, 
     axis.args=list(at=PD_brk,
                    labels=PD_brk),
     breaks=PD_brk2,
     col=colorRampPalette(c('darkblue','white','red'))(11))
plot(mundi, axes = F, add=T)

# FD-loss SES
SR <- cbind(dataset_[-which(dataset_$FD_closs_ses<(-10)),1:2],
            Var=dataset_$FD_closs_ses[-which(dataset_$FD_closs_ses<(-10))])
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
FD_raster <- raster(SR)
plot(FD_raster, main='Functional diversity loss (SES)',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(FD_raster,add=T,axes=F,box=F, 
     axis.args=list(at=FD_brk,
                    labels=FD_brk),
     breaks=FD_brk2,
     col=colorRampPalette(c('darkblue','white','red'))(11))
plot(mundi, axes = F, add=T)

# bivariate map

bivmap <- bivariate.map(PD_raster, FD_raster, colormatrix=col.matrix, nquantiles=4)
col.matrix <- colmat(nquantiles=4, 
                     upperleft="blue", 
                     upperright="red", 
                     bottomleft="snow", 
                     bottomright="green", 
                     xlab="PD-loss", ylab="FD-loss",
                     .plot=F)

plot(FD_raster, main='',axes=F,box=F, col='white',legend=F)
plot(land, col="gray",border="gray",add=T)
plot(bivmap,frame.plot=F,axes=F,box=F,add=T,legend=F,col=as.vector(col.matrix))
plot(mundi, axes = F, add=T)

dev.off()

pdf("Figs/col_legend.pdf",2.5,3)
col.matrix <- colmat(nquantiles=4, 
                     upperleft="blue", 
                     upperright="red", 
                     bottomleft="snow", 
                     bottomright="green", 
                     xlab="PD loss", ylab="FD loss")
dev.off()

##################

test <- data.frame(x = density(na.omit(dataset_$PD_closs_ses_mean_))$x, 
                   y = density(na.omit(dataset_$PD_closs_ses_mean_))$y)

density_PD <- ggplot(data.frame(x = test$x, y = test$y), aes(x, y)) + geom_line() + 
  geom_segment(aes(xend = x, yend = 0, colour = x)) + 
  theme_bw()+
  scale_colour_gradient2(low="darkblue",mid="white",high="red")


test <- data.frame(x = density(na.omit(dataset_$FD_closs_ses[-which(dataset_$FD_closs_ses<(-10))]))$x, 
                   y = density(na.omit(dataset_$FD_closs_ses[-which(dataset_$FD_closs_ses<(-10))]))$y)

density_FD <- ggplot(data.frame(x = test$x, y = test$y), aes(x, y)) + geom_line() + 
  geom_segment(aes(xend = x, yend = 0, colour = x)) + 
  theme_bw()+
  scale_colour_gradient2(low="darkblue",mid="white",high="red")

test <- data.frame(x = density(na.omit(diff))$x, 
                   y = density(na.omit(diff))$y)

density_PDFD <- ggplot(data.frame(x = test$x, y = test$y), aes(x, y)) + geom_line() + 
  geom_segment(aes(xend = x, yend = 0, colour = x)) + 
  theme_bw()+
  scale_colour_gradient2(low="darkblue",mid="white",high="red")

pdf("Figs/Fig2_Loss_SES_hist.pdf", width = 5, height = 3.333333)

plot_grid(density_PD, density_FD, 
          align = 'v',
          nrow = 2)
dev.off()


```

##Figure. Loss quantiles
```{r echo=F, results="hide"}

# For quantiles
breakpoints <- c(0, 2.5, 5, 25, 50, 75, 95, 97.5, 100)
colors <- c("darkblue","blue","white","white","white","white","pink","red")

# X11(width = 10, height = 5)
pdf("Figs/Fig2_Loss_quantiles.pdf", width = 10, height = 2)

layout(matrix(c(1:2), ncol = 2, byrow = T))
par(mar=c(1,0,1.2,1))

# PD-loss quantile
SR <- cbind(dataset_[,1:2],Var=dataset_$PD_closs_quant*100)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
PD_quant <- raster(SR)
plot(PD_quant, main='Phylogenetic diversity loss (Quantile)',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(PD_quant,add=T,axes=F,box=F, 
     breaks=breakpoints, col=colors)
plot(mundi, axes = F, add=T)


# FD-loss quantile
SR <- cbind(dataset_[,1:2],Var=dataset_$FD_closs_quant*100)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
FD_quant <- raster(SR)
plot(FD_quant, main='Functional diversity loss (Quantile)',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(FD_quant,add=T,axes=F,box=F, 
     breaks=breakpoints, col=colors)
plot(mundi, axes = F, add=T)

dev.off()
```

##Figure. Loss SES 2
```{r echo=F, results="hide"}

# Get class intervals PD SES
max_abolute_PD <- max(abs(c(na.omit(dataset_$PD_closs_ses_mean_))))
brk1 <- round(func_splint(c(0,min(na.omit(dataset_$PD_closs_ses_mean_))),3),2)
brk2 <- round(func_splint(c(0,max(na.omit(dataset_$PD_closs_ses_mean_))),3),2)
PD_brk <- unique(sort(c(brk1,brk2)))

# Get class intervals FD SES
max_abolute_FD <- max(abs(c(na.omit(dataset_$FD_closs_ses))))
brk1 <- round(func_splint(c(0,min(na.omit(dataset_$FD_closs_ses))),3),2)
brk2 <- round(func_splint(c(0,max(na.omit(dataset_$FD_closs_ses))),3),2)
FD_brk <- unique(sort(c(brk1,brk2)))

brk12 <- round(func_splint(c(-3,min(na.omit(dataset_$FD_closs_ses))),6),2)
brk22 <- round(func_splint(c(3,max(na.omit(dataset_$FD_closs_ses))),6),2)
FD_brk2 <- unique(sort(c(brk12,brk22)))

# X11(width = 10, height = 5)
pdf("Figs/Fig2_Loss_SES_2.pdf", width = 5, height = 5)

layout(matrix(c(1:3), ncol = 1, byrow = T))
par(mar=c(1,0,1.2,1))


# PD-loss SES
SR <- cbind(dataset_[,1:2],Var=dataset_$PD_closs_ses_mean_)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR, main='Phylogenetic diversity loss (SES)',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR,add=T,axes=F,box=F, 
     axis.args=list(at=PD_brk,
                    labels=PD_brk),
     zlim=round(c(-max_abolute_PD,max_abolute_PD),1),
     col=colorRampPalette(c('darkblue','white','red'))(11))
plot(mundi, axes = F, add=T)


# FD-loss SES
SR <- cbind(dataset_[,1:2],Var=dataset_$FD_closs_ses)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR, main='Functional diversity loss (SES)',axes=F,box=F, col='white',legend=F)
plot(land, add=T,col="gray",border="gray")
plot(SR,add=T,axes=F,box=F, 
     axis.args=list(at=FD_brk,
                    labels=FD_brk),
     breaks=FD_brk2,
     col=colorRampPalette(c('darkblue','white','red'))(11))
plot(mundi, axes = F, add=T)


# RGB
plot(SR,main="",axes=F,box=F, col='white',legend=F)
plotRGB(SR_PD_FD, stretch='lin', add=T)
plot(mundi, axes = F, add=T)

dev.off()



```


##Figure. SD future diversity pattern.    
```{r echo=F, results="hide"}
# X11(width = 10, height = 5)
pdf("Figs/Supp_Fig2_SD_Loss.pdf", width = 5, height = 3.7)

layout(matrix(c(1:3), ncol = 1, byrow = T))
par(mar=c(1,0,1,1))

rampa <- colorRampPalette(c('cornflowerblue','yellow','red'))(10)

# SD richness-loss
SR <- cbind(data.frame(XY),Var=apply(SPD_closs,1,sd))
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(land,main='Species richness loss (SD)', col="gray",border="gray")
plot(SR,axes=F,box=F, col=rampa,add=T)
plot(mundi, axes = F, add=T)

# SD PD-loss
SR <- cbind(data.frame(XY),Var=apply(PD_closs,1,sd))
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(land,main='Phylogenetyc diversity loss (SD)', col="gray",border="gray")
plot(SR,axes=F,box=F, col=rampa,add=T)
plot(mundi, axes = F, add=T)

# SD FD-loss
SR <- cbind(data.frame(XY),Var=apply(FD_closs,1,sd)*100)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(land,main='Functional diversity loss (SD)', col="gray",border="gray")
plot(SR,axes=F,box=F, col=rampa,add=T)
plot(mundi, axes = F, add=T)

dev.off()
```
*** 

\newpage

##Figure. RGB future diversity pattern.    
```{r echo=F, results="hide"}
# %
tmp_data <-data.frame(dataset_[,1:2],
                      SPD = range01(dataset_$SPD_closs.p),
                      PD = range01(dataset_$PD_closs.p),
                      FD = range01(dataset_$FD_closs.p))

tmp_data <- na.omit(tmp_data)
tmp_data$sum <- rowSums(tmp_data[,3:5])
                   
tmp_data$SPD <- tmp_data$SPD / tmp_data$sum
tmp_data$PD <- tmp_data$PD / tmp_data$sum 
tmp_data$FD <- tmp_data$FD / tmp_data$sum 

SR <- cbind(data.frame(tmp_data[,1:2]),Var=tmp_data$SPD)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
raster_sr_loss <- raster(SR)

PD <- cbind(data.frame(tmp_data[,1:2]),Var=tmp_data$PD)
coordinates(PD)<-~x+y
gridded(PD) <- TRUE
raster_PD_loss <- raster(PD)

FD <- cbind(data.frame(tmp_data[,1:2]),Var=tmp_data$FD)
coordinates(FD)<-~x+y
gridded(FD) <- TRUE
raster_FD_loss <- raster(FD)

SR_PD_FD <- stack(raster_FD_loss,raster_sr_loss,raster_PD_loss)

# X11(width = 10, height = 5)
pdf("Figs/Supp_Fig2_RGB_Loss.pdf", width = 5, height = 3.7)

plotRGB(SR_PD_FD, stretch='lin')
plot(mundi, axes = F, add=T)

dev.off()
```


## Realms
```{r}

# SES
######## also test with quantiles
dataplot <- na.omit(data.frame(dataset_[,1:2],
                               SPD_closs = dataset_$SPD_closs,
                               PD_closs = dataset_$PD_closs_ses_mean_,
                               FD_closs = dataset_$FD_closs_ses,
                               Realm = dataset_$Realm))

dataplot$diff <- dataplot$FD_closs - dataplot$PD_closs

tgc <- ddply(dataplot, "Realm", summarise,
             N    = length(diff),
             median = median(diff), # median value
             sd   = sd(diff), # standard deviation
             se   = sd / sqrt(N), # standard error
             ci = se * qt(.95/2 + .5, N-1) # confidence interval 95%
)

pdf(paste("Figs/Fig1_realms_quant.pdf",sep=""),width=5,height=2,useDingbats=F)
ggplot(tgc, aes(x=Realm, y=median, color=Realm))+
  geom_hline(yintercept=0,linetype = "dashed") +
  geom_point(position=position_dodge(.9), size=3) +
  # geom_point(data=dataplot, aes(x=Realm, y=diff, color=Realm, fill=Realm), position=position_dodge(0.9), size=1,alpha=.05) +
  geom_errorbar(position=position_dodge(.9), size= .5, width=0, aes(ymin=median-ci, ymax=median+ci)) +
  theme_bw()+
  theme(legend.position="none") +
  coord_flip() +
  # ylim(-6, 6) + 
  scale_color_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D",
                              "#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray")) +
  scale_x_discrete(limits=sort(unique(tgc$Realm), decreasing = T)) +
  labs(x = "", y = "") # XY Labels
dev.off()


# %
######## also test with quantiles
dataplot <- na.omit(data.frame(dataset_[,1:2],
                               SPD_closs = dataset_$SPD_closs,
                               PD_closs = dataset_$PD_closs.p,
                               FD_closs = dataset_$FD_closs.p,
                               Realm = dataset_$Realm))

dataplot$diff <- dataplot$FD_closs - dataplot$PD_closs

tgc <- ddply(dataplot, "Realm", summarise,
             N    = length(diff),
             median = median(diff), # median value
             sd   = sd(diff), # standard deviation
             se   = sd / sqrt(N), # standard error
             ci = se * qt(.95/2 + .5, N-1) # confidence interval 95%
)

pdf(paste("Figs/Fig1_realms_p.pdf",sep=""),width=5,height=2,useDingbats=F)
ggplot(tgc, aes(x=Realm, y=median, color=Realm))+
  geom_hline(yintercept=0,linetype = "dashed") +
  geom_point(position=position_dodge(.9), size=3) +
  # geom_point(data=dataplot, aes(x=Realm, y=diff, color=Realm, fill=Realm), position=position_dodge(0.9), size=1,alpha=.05) +
  geom_errorbar(position=position_dodge(.9), size= .5, width=0, aes(ymin=median-ci, ymax=median+ci)) +
  theme_bw()+
  theme(legend.position="none") +
  coord_flip() +
  # ylim(-6, 6) + 
  scale_color_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D",
                              "#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray")) +
  scale_x_discrete(limits=sort(unique(tgc$Realm), decreasing = T)) +
  labs(x = "", y = "") # XY Labels
dev.off()



## realm plot
realm_raster <- cbind(data.frame(XY),Var=Realm)
coordinates(realm_raster)<-~x+y
gridded(realm_raster) <- TRUE
realm_raster <- raster(realm_raster)

pdf("Figs/Fig2_realm_legend.pdf", width = 10, height = 10/3)
plot(land, col="white",border="white")
plot(realm_raster,add=T,axes=F,box=F, 
     col=colorRampPalette(c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D","#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray"))(11))
plot(mundi, axes = F, add=T)
dev.off()

###########################################

# Raw
dataplot <- na.omit(data.frame(XY,
                               SPD_closs = dataset$SPD_closs,
                               PD_closs = dataset$PD_closs,
                               FD_closs = dataset$FD_closs*100,
                               Realm = dataset$Realm))

dataplot$diff <-  scale(log(dataplot$FD_closs+1)) - scale(log(dataplot$PD_closs+1))

tgc <- ddply(dataplot, "Realm", summarise,
               N    = length(diff),
               median = median(diff), # median value
               sd   = sd(diff), # standard deviation
               se   = sd / sqrt(N), # standard error
              ci = se * qt(.95/2 + .5, N-1) # confidence interval 95%
)

pdf(paste("Figs/Fig1_realms.pdf",sep=""),width=5,height=2,useDingbats=F)
ggplot(tgc, aes(x=Realm, y=median, color=Realm))+
  geom_hline(yintercept=0,linetype = "dashed") +
  geom_point(position=position_dodge(.9), size=3) +
  # geom_point(data=dataplot, aes(x=Realm, y=diff, color=Realm, fill=Realm), position=position_dodge(0.9), size=1,alpha=.05) +
  geom_errorbar(position=position_dodge(.9), size= .5, width=0, aes(ymin=median-ci, ymax=median+ci)) +
  theme_bw()+
  theme(legend.position="none") +
  coord_flip() +
  # ylim(-6, 6) + 
  scale_color_manual(values=c("#F8766D","#D89000","#A3A500","#39B600","#00BF7D",
                              "#00BFC4","#00B0F6","#9590FF","#E76BF3", "#FF62BC", "gray")) +
  scale_x_discrete(limits=sort(unique(tgc$Realm), decreasing = T)) +
  labs(x = "", y = "") # XY Labels
dev.off()


### Difference loss
max_abolute_PD <- max(abs(c(na.omit(dataplot$diff))))
brk1 <- round(func_splint(c(-max_abolute_PD,0),3),1)
brk2 <- round(func_splint(c(0,max_abolute_PD),3),1)
PD_brk <- unique(sort(c(brk1,brk2)))

pdf("Figs/Fig2_Diff_Loss.pdf", width = 10, height = 10/3)

SR <- cbind(dataplot[,1:2],Var=dataplot$diff)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(land, col="gray",border="gray")
plot(SR,add=T,axes=F,box=F, 
     axis.args=list(at=PD_brk,
                    labels=PD_brk), 
     zlim=round(c(-max_abolute_PD,max_abolute_PD),1),
     col=colorRampPalette(c('darkblue','white','red'))(20))
plot(mundi, axes = F, add=T)

dev.off()
```

##Figure. Assemblages that will loss all species
```{r}
pdf("60_percent_loss.pdf", width = 5, height = 5/3, useDingbats=F)
par(mar=c(2,0,1,0))

# % richness loss
SR <- cbind(data.frame(XY),Var=SPD_closs.p)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR>60, main='Optimistic scenario',col=c('white','red'), axes=F,box=F,legend=F)
plot(mundi, axes = F, add=T, lwd=.1)

dev.off()
```

##Figure. High/Low PD/FD-loss
```{r}
pdf("High_low_loss.pdf", width = 11, height = 5, useDingbats=F)
layout(matrix(c(1:4),2,2, byrow = F))
par(mar=c(0,0,2,0))

# High/Low PD-loss
more <- 1.96
less <- -1.96
PDlossS1HL <- rep(2,length(PDS1.loss.ses))
PDlossS1HL[which(PDS1.loss.ses>more)] <- 3
PDlossS1HL[which(PDS1.loss.ses<less)] <- 1

SR <- cbind(data.frame(XY),Var=PDlossS1HL)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR, main='Optimistic scenario\nPD-loss',col=c('white','red'), axes=F,box=F,legend=F)
plot(mundi, axes = F, add=T, lwd=.1)

# High/Low FD-loss
more <- 1.96
less <- -1.96
FDlossS1HL <- rep(2,length(FDS1.loss.ses))
FDlossS1HL[which(FDS1.loss.ses>more)] <- 3
FDlossS1HL[which(FDS1.loss.ses<less)] <- 1

SR <- cbind(data.frame(XY),Var=FDlossS1HL)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR, main='Optimistic scenario\nFD-loss',col=c("blue",'white','red'), axes=F,box=F,legend=F)
plot(mundi, axes = F, add=T, lwd=.1)

# High/Low PD-loss
more <- 1.96
less <- -1.96
PDlossS2HL <- rep(2,length(PDS2.loss.ses))
PDlossS2HL[which(PDS2.loss.ses>more)] <- 3
PDlossS2HL[which(PDS2.loss.ses<less)] <- 1

SR <- cbind(data.frame(XY),Var=PDlossS2HL)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR, main='Pessimistic scenario\nPD-loss',col=c("blue",'white','red'), axes=F,box=F,legend=F)
plot(mundi, axes = F, add=T, lwd=.1)

# High/Low FD-loss
more <- 1.96
less <- -1.96
FDlossS2HL <- rep(2,length(FDS2.loss.ses))
FDlossS2HL[which(FDS2.loss.ses>more)] <- 3
FDlossS2HL[which(FDS2.loss.ses<less)] <- 1

SR <- cbind(data.frame(XY),Var=FDlossS2HL)
coordinates(SR)<-~x+y
gridded(SR) <- TRUE
SR <- raster(SR)
plot(SR, main='Pessimistic scenario\nFD-loss',col=c("blue",'white','red'), axes=F,box=F,legend=F)
plot(mundi, axes = F, add=T, lwd=.1)

dev.off()
```



#Spatial models
```{r eval=F}

# Models

modelos <- list(as.formula(paste("scale(FD_cc)~", "scale(PD_cc)",sep = "")), # PD vs FD
                as.formula(paste("scale(FD_cc_ses)~", "scale(PD_cc_ses)",sep = "")), # PDses vs FDses
                as.formula(paste("scale(FD_closs)~", "scale(PD_closs)",sep = "")), # PDloss vs FDloss
                as.formula(paste("scale(PD_closs.p)~", "scale(FD_closs.p)",sep = "")), # PDloss.p vs PDloss.p
                as.formula(paste("scale(FD_closs_ses)~", "scale(PD_closs_ses)",sep = "")), # PDloss.ses vs FDloss.ses
                as.formula(paste("scale(SPD_closs)~", "scale(PD_closs)",sep = "")), # SPDloss vs PDloss
                as.formula(paste("scale(SPD_closs)~", "scale(FD_closs)",sep = "")), # SPDloss vs FDloss
                as.formula(paste("scale(SPD_closs.p)~", "scale(PD_closs.p)",sep = "")), # SPDloss.p vs PDloss.p
                as.formula(paste("scale(SPD_closs.p)~", "scale(FD_closs.p)",sep = ""))) # SPDloss.p vs FDloss.p
       
 
# set cluster
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)

start_time <- Sys.time()

# calculate OLS and SAR in parallel
models <- foreach(i=1:length(modelos), .packages=c('spdep')) %dopar% { 
  test <- lm(modelos[[i]], data = na.omit(dataset_))
  # check correlogram
  correl <- pgirmess::correlog(coords=na.omit(dataset_)[names(residuals(test)),1:2], 
                               z=residuals(test), method="Moran")
  correl <- data.frame(correl)
  # Define define a connectivity (neighbourhood) matrix
  # set distance 2 as the second distance class
  nbdist<-dnearneigh(x=as.matrix(na.omit(dataset_)[,1:2]), d1=0, d2=correl$dist.class[2]) # define connectivity matrix (0/1)
  neigh.dist<-nbdists(nbdist, as.matrix(na.omit(dataset_)[,1:2]), longlat=F) # compute the Euclidean distance between neighbouring sites
  inverse<-lapply(neigh.dist, function(x) (1/(x^2))) # compute the inverse distance weigthed matrix
  nlw<-nb2listw(neighbours=nbdist, glist=inverse, style="W", zero.policy=FALSE) # coding style W = row standardised
  
  sar.model <- spatialreg::errorsarlm(modelos[[i]], data=na.omit(dataset_), listw=nlw)
  
  lm.models.moran <- moran.test(resid(test), listw=nlw, alternative="greater")
  sar.models.moran <- moran.test(resid(sar.model), listw=nlw, alternative="greater")
  
  return(list(sar.model, lm.models.moran, sar.models.moran))
}
totaltime <- Sys.time() - start_time 
# 22 secs
# stop the cluster
stopCluster(cl)


# Calculate correlograms

# set cluster
ncores <- detectCores()
cl <- makeCluster(ncores)
registerDoParallel(cl)

start_time <- Sys.time()

correls <- foreach(i=1:length(modelos), .packages=c('pgirmess')) %dopar% { 
  lmodel <- lm(modelos[[i]], data=na.omit(dataset_))
  correl.lm <- pgirmess::correlog(coords=na.omit(dataset_)[names(residuals(lmodel)),1:2], 
                                  z=residuals(lmodel), method="Moran")
  correl.lm <- data.frame(correl.lm)
  
  correl.sar <- pgirmess::correlog(coords=na.omit(dataset_)[names(residuals(models[[i]][[1]])),1:2], 
                                   z=residuals(models[[i]][[1]]), method="Moran")
  correl.sar <- data.frame(correl.sar)
  
  return(list(correl.lm, correl.sar))
  
}

# stop the cluster
stopCluster(cl)


# Get data

res_models <- data.frame(model=as.character(modelos),Coeff=NA,R2=NA,MoranLM=NA, MoranSAR=NA)
for (i in 1:length(models)){
  tmp <- summary(models[[i]][[1]], Nagelkerke = T)
  res_models$Coeff[i] <- paste(round(tmp$Coef[2,1],2), " (", ps(tmp$Coef[2,4]), ")", sep = "")
  res_models$R2[i] <- round(tmp$NK,2)
  res_models$MoranLM[i] <- paste(round(models[[i]][[2]]$statistic,2),
                            ps(round(models[[i]][[2]]$p.value,2)))
  res_models$MoranSAR[i] <- paste(round(models[[i]][[3]]$statistic,2),
                            ps(round(models[[i]][[3]]$p.value,2)))
}

write.csv(res_models, "Figs/model_output.csv")

# plot correlograms

pdf("Figs/correlograms.pdf",width = 10, height = 10)
par(mfrow = c(2,2))

plot(0,main="FD ~ PD",type="n",col="black",
     ylab="Moran's I",xlab="lag distance", 
     xlim=c(0,15000000), ylim=c(-.1,1), cex.main=2, cex.lab=1.7, cex.axis=1.7)
abline(h=0,lty="dotted")
lines(correls[[1]][[1]]$coef~correls[[1]][[1]]$dist.class,col="red",lwd=2)
lines(correls[[1]][[2]]$coef~correls[[1]][[2]]$dist.class,col="blue",lwd=2)
# Anotate
legend(x=2000, y=1, legend="OLS", pch="_", bty="n", cex=2, col = "red")
legend(x=2000, y=.9, legend="SARerr", pch="_", bty="n", cex=2, col = "blue")

plot(0,main="FD SES ~ PD SES",type="n",col="black",
     ylab="Moran's I",xlab="lag distance", 
     xlim=c(0,15000000), ylim=c(-.1,1), cex.main=2, cex.lab=1.7, cex.axis=1.7)
abline(h=0,lty="dotted")
lines(correls[[2]][[1]]$coef~correls[[2]][[1]]$dist.class,col="red",lwd=2)
lines(correls[[2]][[2]]$coef~correls[[2]][[2]]$dist.class,col="blue",lwd=2)

plot(0,main="FD loss ~ PD loss",type="n",col="black",
     ylab="Moran's I",xlab="lag distance", 
     xlim=c(0,15000000), ylim=c(-.1,1), cex.main=2, cex.lab=1.7, cex.axis=1.7)
abline(h=0,lty="dotted")
lines(correls[[3]][[1]]$coef~correls[[3]][[1]]$dist.class,col="red",lwd=2)
lines(correls[[3]][[2]]$coef~correls[[3]][[2]]$dist.class,col="blue",lwd=2)

plot(0,main="FD loss SES ~ PD loss SES",type="n",col="black",
     ylab="Moran's I",xlab="lag distance", 
     xlim=c(0,15000000), ylim=c(-.1,1), cex.main=2, cex.lab=1.7, cex.axis=1.7)
abline(h=0,lty="dotted")
lines(correls[[5]][[1]]$coef~correls[[5]][[1]]$dist.class,col="red",lwd=2)
lines(correls[[5]][[2]]$coef~correls[[5]][[2]]$dist.class,col="blue",lwd=2)

dev.off()

```

# Phylogenetic signal
## Prepare
```{r phylogenetic_signal_prepare, warning= F}
IUCN$risk[which(IUCN$IUCN=="CR"|IUCN$IUCN=="EN")] <- "RISK"
IUCN$risk[which(!(IUCN$IUCN=="CR"|IUCN$IUCN=="EN"))] <- "N-RISK"

IUCN$risk2[which(IUCN$IUCN=="CR"|IUCN$IUCN=="EN"|IUCN$IUCN=="NT"|IUCN$IUCN=="VU")] <- "RISK"
IUCN$risk2[which(!(IUCN$IUCN=="CR"|IUCN$IUCN=="EN"|IUCN$IUCN=="NT"|IUCN$IUCN=="VU"))] <- "N-RISK"
 
library(caper)
# Make a comaprative dataset
sigrisk <- comparative.data(tree, IUCN, "Species")
# The value of D can be both smaller than 0 (highly conserved) and greater than 1 (overdispersed) and the distributions of scaled D from the simulations are used to assess the significance of the observed scaled D. The plot method generates density plots of the distributions of the two simulations relative to the observed D value.
sigS1 <- phylo.d(sigrisk, binvar=risk)
plot(sigS1)
sigS2 <- phylo.d(sigrisk, binvar=risk2)
plot(sigS2)
```

# Amphibian phylogeny
```{r , echo=F}
tree2 <- tree
tree2 <- ladderize(tree2, right = F) # this messes tip sequencies when plotting
tree2$tip.label <- as.character(tree2$tip.label)

taxa <- read.csv("amph_shl_new_Classification_Pyron.csv")
names(taxa)[6] <-"Species"
taxa$Species <- gsub(" ","_",taxa$Species)

total.tree <- read.tree('Pyron_tree_new.txt')
taxa_namesnew <- read.csv('tree_names_fixed.csv')
taxa_namesnew$X <- taxa_namesnew$Species
taxa_namesnew$Species <- total.tree$tip.label

taxa <- merge(taxa, taxa_namesnew,by="Species")
taxa$Species <- taxa$X

states <- IUCN
states <- merge(states,taxa,by="Species",all.x = T)
states <- states[-which(duplicated(states$Species)),]

rownames(states) <- as.character(states$Species)
states <- states[as.character(tree2$tip.label),] # same order
states$prob <- 1 - states$prob
states$Species <- as.character(states$Species)
tree2$tip.state <- states

th <- max(branching.times(tree2))
gr.col <- gray.colors(2, start=0.97, end=0.999)

## sequency black gray for families
is_tip <- tree2$edge[,2] <= length(tree2$tip.label)
ordered_tips <- tree2$edge[is_tip, 2]

plotord <- rev(unique(states$Family[ordered_tips]))

if(length(plotord)==length(unique(states$Family))) {   cat("Cool!!\nIt worked. \nFamily names match") } else {     cat("ops... something went wrong. Try again. \nReview family names...") }

xx <- c(rep(c("black", "grey"), floor(length(plotord)/2)))
if(length(xx) < length(plotord)) { xx <- c(xx,'black') } # if length xx is even, add 'black'.
xx <- xx[order(plotord)]

#View(cbind(plotord[order(plotord)],xx))

xx2 <- data.frame(cbind(plotord[order(plotord)],xx))
colnames(xx2) <- c('Family', 'color')

xx3 <- merge(xx2, states, by='Family')

####### ####### ####### ####### ####### ####### ####### ####### ####### ####### ####### 
####### PLOT
####### ####### ####### ####### ####### ####### ####### ####### ####### ####### ####### 

obj <- plot2.phylo(plot=F, tree2, type="f", edge.width=0.01, label.offset=0.5, no.margin=T, 
                   show.tip.label=FALSE, x.lim=c(-th*1.57,th*1.57), y.lim=c(-th*1.57,th*1.57))


pdf("Figs/phy.pdf",height=10, width=10)

# x11(height=10, width=10)
par(mai=rep(1000, 4))

plot(tree2, type="f", cex=0.4, label.offset=0.1, no.margin=T, show.tip.label=FALSE, plot=FALSE,
     x.lim=c(-th*1.57,th*1.57), y.lim=c(-th*1.57,th*1.57))

draw.circle(0,0, radius=th, col =gr.col[1], border=gr.col[1])
draw.circle(0,0, radius=th-20, col=gr.col[2], border=gr.col[2])
draw.circle(0,0, radius=th-40, col =gr.col[1], border=gr.col[1])
draw.circle(0,0, radius=th-60, col=gr.col[2], border=gr.col[2])
draw.circle(0,0, radius=th-80, col =gr.col[1], border=gr.col[1])
draw.circle(0,0, radius=th-100, col=gr.col[2], border=gr.col[2])
draw.circle(0,0, radius=th-120, col=gr.col[1], border=gr.col[1])
draw.circle(0,0, radius=th-140, col =gr.col[2], border=gr.col[2])
draw.circle(0,0, radius=th-160, col=gr.col[1], border=gr.col[1])
draw.circle(0,0, radius=th-180, col =gr.col[2], border=gr.col[2])
draw.circle(0,0, radius=th-200, col=gr.col[1], border=gr.col[1])
draw.circle(0,0, radius=th-220, col=gr.col[2], border=gr.col[2])
draw.circle(0,0, radius=th-240, col =gr.col[1], border=gr.col[1])
draw.circle(0,0, radius=th-260, col=gr.col[2], border=gr.col[2])
draw.circle(0,0, radius=th-280, col =gr.col[1], border=gr.col[1])
draw.circle(0,0, radius=th-300, col=gr.col[2], border=gr.col[2])

par(new=TRUE)

trait_col <- states$prob
names(trait_col) <- states$Species
  
plotBranchbyTrait(tree2, x = trait_col, type="f", mode = "tips",
                  edge.width=.5, label.offset=0.5, no.margin=T, show.tip.label=FALSE, 
                  x.lim=c(-th*1.57,th*1.57), y.lim=c(-th*1.57,th*1.57),
                  palette=colorRampPalette(c("darkblue","blue","lightblue","yellow","orange","red")))

group.label.tip(obj, as.character(tree2$tip.state$Family), xx, "black",
                offset.bar=th/40, offset.lab=th/20,
                cex=.7, lwd=7, check = F)

dev.off()

```

# Supp table & figures
```{r}
# how many communities with high PD-loss, low PD-loss, high FD-loss, and loss FD-loss? 
#Values greater than 1.96 indicate a higher than expected functional dissimilarity between the communities and values below -1.96 indicate a lower than expected functional dissimilarity between the two communities.

HPDL <- (length(which(PDS1.loss.ses > 1.96))/length(PDS1.loss.ses))*100 # high PD-loss
LPDL <- (length(which(PDS1.loss.ses < -1.96))/length(PDS1.loss.ses))*100 # low PD-loss
HFDL <- (length(which(FDS1.loss.ses > 1.96))/length(FDS1.loss.ses))*100 # high FD-loss
LFDL <- (length(which(FDS1.loss.ses < -1.96))/length(FDS1.loss.ses))*100 # low FD-loss

HPDL <- (length(which(PDS2.loss.ses > 1.96))/length(PDS2.loss.ses))*100 # high PD-loss
LPDL <- (length(which(PDS2.loss.ses < -1.96))/length(PDS2.loss.ses))*100 # low PD-loss
HFDL <- (length(which(FDS2.loss.ses > 1.96))/length(FDS2.loss.ses))*100 # high FD-loss
LFDL <- (length(which(FDS2.loss.ses < -1.96))/length(FDS2.loss.ses))*100 # low FD-loss
```

# save image
```{r eval = F, echo = F}
save.image("PD+FD_erosion_new.RData")
```
#END OF CODE
